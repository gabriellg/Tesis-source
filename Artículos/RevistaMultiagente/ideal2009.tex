\documentclass[runningheads]{llncs}

\usepackage{amssymb}
\usepackage{amsmath}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
%\usepackage[spanish]{babel}
\usepackage{url}


\begin{document}

\mainmatter


\title{Sistemas Multiagentes en Realidad Virtual}
\titlerunning{Sistemas Multiagentes en Realidad Virtual}

%\toctitle{Sistemas Multiagentes en Realidad Virtual}


\author{Gabriel L\'opez Garc\'ia \and Rafael Molina Carmona \and Antonio Javier Gallego S\'anchez}
\authorrunning{Gabriel L\'opez \and Rafael Molina \and Antonio Javier Gallego}

%\tocauthor{G. LÃ³pez \and R. Molina \and A. J. Gallego}


%\institute{Grupo de Inform\'atica Industrial e Inteligencia Artificial\\
%Universidad de Alicante, Ap.99, E-03080, Alicante, Spain\\
%\{glopez, rmolina, ajgallego\}@dccia.ua.es}





\maketitle


\begin{abstract}
..............

8 pages.

It should contain at least 70 and at most 150 words.

..............

%\keywords{We would like to encourage you to list your keywords within
%the abstract section}
\end{abstract}



%___________________________________________________________________________
\section{Introduction
\label{sec:introduction}}
%___________________________________________________________________________

The growing influence of Multi-Agent Systems (MAS) in several fields of research has led to a significant evolution in its development. Its application can be seen in a wide variety of disciplines such as sociology, economics, artificial intelligence, ecology, and so on. Some of the features that make these systems attractive include its power to simulate many types of situations, with different strategies and under different conditions. They also provide the richness needed to describe scenarios where the diversity and complexity are essential. Another important features is the ability of its components (agents) to communicate.

On the other hand, the spectacular progress of the Interactive Graphic Systems (IGS) has contributed to present the information in our environment in a more friendly way using new forms of analysis. Videogames and the entertainment industry in general, have had a decisive influence on this spectacular progress, developing excellent rendering and interaction systems, all at a reasonable cost. As a consequence, the way to visualize the information in videogames and in ISGs in general, has arrived to the field of research [Rhyne,2000].

The definition of an agent usually consists of a set of generic characteristics (autonomy, social skills, reactivity and proactivity [Gilbert,2008]) that make them difficult to model. Although there are some common strategies for implementing them, there is clearly a lack of a unified design pattern. As a consequence, some difficulties arise. One of these is the difficult reproduction of the results provided by the MASs, which supposes a tedious task of verification by several research teams [Axelrod,1997]. If the agents also include random characteristics to simulate strategies, the repetition of experiments becomes almost impossible [Gilbert,2008]. On the other hand, the visual representation of the MAS usually has a secondary character and is not sufficiently engaged, even if it is true that in recent years, there are some work environments that consider the visualization of the agents as an additional feature ([Luke et Al,2005], [North,2005], [Wilensky,1999]). Another problem associated with MAS refers to the possibility of changing the initial conditions of a given experiment in real time. This would enrich the results of the experiments and would be another interesting contribution provided by interactive systems. Therefore, the aid the IGSs can offer can be very interesting, both for the visualization of the MAS and for interactive testing.

In MASs, the connection of the agents with the environment has a vital importance. This relationship affects the activities of the agent, conditioning its behavior. For example, an agent can execute different actions if there is a risk of collision, if there is an attraction force (eg gravity) or if it must avoid an object. Within the IGS, the module responsible for managing the effects of environment on the objects in the scene is often called Physics Engine. The possibility of connecting the activities of agents with the effects of the Physics Engine would be very interesting, especially if the engine is implemented, as sometimes happens, on dedicated hardware.

On the other hand, IGSs are often part of more complex systems that attempt to model reality by incorporating, in addition to the aesthetic aspects, other aspects of behavior. A MASs could provide an intelligent behavior. That is the case, for example, of Virtual Reality systems in which the characters or avatars may have an agent-guided behavior.

The definition of a model that unifies the best of the MASs and the IGSs would be a major step in the evolution of these types of systems. This model would allow the specification of all the features necessary to define an agent, facilitating their visualization and interaction. It should also simplify the reproduction of experiments using a language to describe the scene and its elements, and facilitate the modification of the initial conditions. On the other hand, it could manage the relationship between Physics Engine and the agents, allowing the communication between the two systems. All this would require a common language for describing the scenes and their components.

This paper describes a proposal that incorporates features of the SMA and SG into a model based on grammars. The following section provides a description of the current situation of working environments for the development of SMA including some systems that use graphic resources to visualize the agents. In Section 3 the objectives to be achieved by the proposed model are defined. The proposed model is described in Section 4. Then, in Section 5, a case of study is proposed with the aim of showing the use of the whole system. Finally, some conclusions and possible lines of future work are presented.



%___________________________________________________________________________
\section{Background  /   Previous works
\label{sec:background}}
%___________________________________________________________________________

Nowadays there are many work environments to develop MASs. The main types are: specific environments using MAS-based solutions and work environments that define a generic architecture for the management of the main features of the MASs. However, with few exceptions, solutions to develop MASs where a IGS is an essential component are not proposed. The most common case is just implementing specific features of the MAS, such as the communication between agents, the parallel implementation of the MAS or the execution of different agents on different machines connected by a network.

One area where MASs are being incorporated with great success is Sociology ([Axelrod,1997],[Gilbert,2008], [Sawyer.2005], [Drogoul et Al., ]). In this case, very specific solutions are used, generally oriented to sociological studies. As examples, environments that simulate the movement of crowds can be referred [Ulicny et Al, 2001],[Olfati-Saber, 2004], or problems like the movement of groups of individuals stampeded out [Reynolds,2000]. In some cases, they use graphics to display statistics, or the density of agents within an environment. There are also systems such as the one described in [Reynolds,2000], where an animation of the movements of agents can be observed. Netlog [Wilensky,1999] is one of these environments, developed by Uri Winlesky in 1999 and it is being continually developed. To program the agents script language is used. It allows the implementation of everything that could be needed to define the behaviour. Netlog aims to study highly complex systems, exploring how the macro-behaviors emerge from the micro-behaviors specified for each agent through the script language. This system has developed some graphical features, but the agents are represented by Logo style triangles. This representation allows the user to observe the movement of each of the agents and the population density in different areas of the environment.

Some other applications of the MASs to Virtual Reality systems can be found. These systems usually consist of elements that make up a scene in which the user interaction is complex. One of these systems is described in [Maes et Al.1995] and it proposes an implementation of the virtual world where objects react to several gestures of a user. In the same line, in [Wachsmuth et Al, 1995] a system using the concepts of perception of the MASs applied to virtual reality is described. In this case, the agents react interactively with the user. As a final example, the work of [Gratch et Al, 2002] makes use of avatars to make the interaction with users more attractive. While not referring directly to agents, it uses very close concepts to those used in MASs as perception and reaction. These avatars react with different behavior to perceptions of the environment. All these examples use graphics systems. Nevertheless, there is no clear mechanism for linking the MAS and the IGS. Furthermore, they do not use generic models to implement MASs.

In the area of the entertainment industry, some MASs applied to games can also be found. In this case, the agents are usually called bots [Khoo et Al., 2002] and they are programmed as characters of the game, with objectives, strategies and actions. Everything is related to the environment around them. Programming is done with a specific script language for each game, so that characters cannot easily be transferred from one game to another, preserving their respective strategies. However, these systems are so successful that they are being used in research for some specific cases [Rhyne,2000]. 

So far, some specific applications of MAS models have been presented. Currently, however, an increasing variety of generic development environments with a similar philosophy are emerging: they implement the most important features of agents, ie, perception of the world, communication, reaction, etc.. [Gilbert,2008].

An example of a working environment for the development of MASs is Jade [Jade]. It has been developed in Java, it implements everything necessary to manage an MAS, it carries out operations of communication between agents and it models different types of activities. It can be run on several networked machines. However, it does not incorporate the possibility of using an IGS and the interaction with the agents is not considered, so interactive changes during the experiments are not possible. 

Repast [North et Al, 2005] is another environment to study simulations of groups of agents. It has an interface which is development for Java,. Net and Python. It is divided into several layers with a core from which to develop specific platforms like Repast S, used for social simulation. The system is based on models that define the behavior of agents. Its main components are the atom and the relationships between atoms. They are placed in a given space and then they can be drawn in 2D or 3D. It uses Eclipse as development environment.

Another environment in line with the previous one is MASON [Luke et Al., 2005]. Is developed in Java and it is defined as a simulation environment for discrete event-based MASs. It is designed for a wide type of applications, from social simulation to learning systems, as well as applications in robotics. The agents are divided into two layers. On the one hand, the layer of the model implements the execution of actions, the state updating and the environment management. On the other hand, if the agent is to be displayed, the display layer must be set. This layer is responsible for drawing the agent depending on its state. MASON ensures that experiments can be replicated regardless of the platform. It has a 2D and 3D visualization system for the agents, and it system can be run in a visual way in the course of time, creating animations.
 
As a conclusion, there are a variety of environments that implement the essential characteristics of the MASs and, in some cases, there are environments that use IGSs to display the agents. However, the system being proposed has as essential feature the implementation of an integrated formal model based on grammars, designed to merge the two areas in question: a MAS and a IGS. This implies that some aspects have been studied, in particular how it should be the communication of both types of systems, so that the systems designed with the formal model are readily available, transportable to different areas of application (simulation, videogames, social analysis). The use different types of visual devices as well as different types of interaction have carefully been considered too.



%___________________________________________________________________________
\section{Objectives
\label{sec:objectives}}
%___________________________________________________________________________

Los objetivos se orientan principalmente a conseguir un modelo que integre los SMA con SG mediante un lenguaje descriptivo y un sistema de eventos discretos. Se pretende que se pueda interactuar fÃ¡cilmente para cambiar las condiciones iniciales, reproducir los experimentos tantas veces como se quiera y visualizar los componentes de la escena en tiempo real, independientemente del equipo donde se estÃ© ejecutando. TambiÃ©n se ha procurado que exista una independencia respecto de los dispositivos tanto visuales, como de interacciÃ³n. AdemÃ¡s, la importancia que tiene la definiciÃ³n del entorno para los SMA [Weyns et Al, 2007], hace necesaria la incorporaciÃ³n del motor fÃ­sico, que ha sido ampliamente estudiado como parte de un SG pero no de un SMA. Esto es especialmente importante si se dispone de tarjetas hardware dedicadas para los cÃ¡lculos necesarios en un motor fÃ­sico, y que por tanto usarÃ­an los SMA.

Para todo esto serÃ­a necesario algÃºn tipo de arquitectura que estructure de forma eficiente e integral todos los requerimientos antes especificados. Esta arquitectura deberÃ¡ ser lo suficientemente flexible como para adaptarse a toda la diversidad que rodea tanto a los SMA, como a los SG. Para lograr esto se propone:


\begin{enumerate}
    \item Definir un motor grÃ¡fico que elimine la diversidad de los diferentes dispositivos visuales. Es decir, se desea que con una Ãºnica descripciÃ³n de la escena se procese de tal manera que se muestre en cualquier dispositivo grÃ¡fico y con un nivel de detalle acorde con sus caracterÃ­sticas.

    \item Dotar al motor grÃ¡fico de la suficiente flexibilidad como para cambiar incluso la representaciÃ³n de los elementos y dar otro tipo de informaciÃ³n, a peticiÃ³n del usuario, sin necesidad de modificar la descripciÃ³n de la escena, enriqueciendo asÃ­ el anÃ¡lisis de los datos arrojados por los SMA.

    \item DiseÃ±ar el motor grÃ¡fico de forma que no sea sÃ³lo especÃ­fico para dispositivos visuales, sino que tambiÃ©n se pueda utilizar para la extracciÃ³n y uso de la geometrÃ­a de los elementos que componen la escena, muy necesaria para que los agentes puedan saber cÃ³mo es el entorno que les rodea.

    \item Definir un motor fÃ­sico que modele toda la actividad del sistema, adaptÃ¡ndose a los diferentes componentes hardware donde se va a ejecutar. Si se dispone de componentes hardware que implementan algoritmos fÃ­sicos, el sistema debe aprovecharlos, pero si por el contrario no existen, los debe implementar mediante software.

    \item DiseÃ±ar el motor fÃ­sico para que pueda, en cualquier momento, pedir al motor grÃ¡fico los datos que necesite y pueda realizar la funciÃ³n de simulaciÃ³n, asÃ­ como el anÃ¡lisis, si fuera necesario, de los elementos que componen la escena. 

    \item Dotar al motor fÃ­sico con la capacidad de poder transmitir la informaciÃ³n procesada por Ã©l a los agentes para que estos puedan tomar decisiones acorde con sus deseos y considerando las limitaciones del entorno. AdemÃ¡s podrÃ¡ modificar los estados de los agentes si asÃ­ lo requiere. Todo esto debe poder realizarse sin necesidad de saber con detalle la arquitectura de los elementos que componen la escena.

    \item Integrar el SMA con el motor fÃ­sico considerando las limitaciones impuestas por Ã©ste. Esto supone que se debe realizar un trabajo importante en la integraciÃ³n de un sistema sobre el otro.

    \item Independizar la interacciÃ³n respecto del sistema de hardware de entrada, de forma que se abstraiga del origen de la interacciÃ³n y procese directamente las Ã³rdenes del usuario. Dicha interacciÃ³n puede provenir, no sÃ³lo de dispositivos fÃ­sicos, sino de procesos internos del sistema que producen interacciÃ³n con la escena (por ejemplo, el cÃ¡lculo de colisiones). De esta manera se podrÃ­an manipular agentes durante el proceso de experimentaciÃ³n de forma interactiva.

    \item Reutilizar los diferentes agentes de forma casi inmediata. Si, por ejemplo, se diseÃ±a un agente para un determinado escenario utilizando los mecanismos proporcionados por el sistema, se podrÃ¡ reutilizar dicho agente en cualquier otra situaciÃ³n o aplicaciÃ³n que gestione un SMA.

    \item Abstraer los elementos diseÃ±ados del origen de la interactividad, de forma que se especifique a quÃ© pueden reaccionar y en quÃ© modo. Sin embargo, no sabrÃ¡n necesariamente cuÃ¡l es la causa del estÃ­mulo al que deben reaccionar.

    \item Toda la comunicaciÃ³n se ejercerÃ¡ mediante eventos, pero siempre sin saber ni especificar cuÃ¡l es origen del evento, dando importancia al evento en sÃ­, y no a su procedencia. Esto tambiÃ©n se refiere a la implementaciÃ³n de la comunicaciÃ³n entre agentes, punto muy importante en los SMA.
    
\end{enumerate}

Para el cumplimiento de todos estos objetivos se utilizarÃ¡n modelos matemÃ¡ticos que formalizarÃ¡n los diferentes componentes, abstrayendo las caracterÃ­sticas que definen los dos tipos de sistemas. Esta fuerte formalizaciÃ³n ayudarÃ¡ a que se construyan fÃ¡cilmente sistemas de generaciÃ³n automÃ¡ticos o visuales que ayuden al desarrollo de los elementos que componen una escena de un SG.


%___________________________________________________________________________
\section{Model for Virtual Worlds Generation
\label{sec:model}}
%___________________________________________________________________________

Un escenario se caracteriza por un conjunto de elementos dinÃ¡micos o agentes, que pueden tener o no una descripciÃ³n geomÃ©trica, y que realizan una actividad en un escenario compuesto por elementos estÃ¡ticos que se visualizan. Esta visualizaciÃ³n se va a definir mediante una secuencia ordenada de primitivas y transformaciones.

El concepto de primitiva se debe considerar, no sÃ³lo como una primitiva de dibujo usual (como el dibujo de una esfera, un cubo, etc.), sino mÃ¡s bien como una acciÃ³n que se debe ejecutar en un determinado sistema geomÃ©trico que puede ser visual o no. Este sistema geomÃ©trico estÃ¡ representado por el conjunto G y cada primitiva es un elemento de dicho conjunto. Como ejemplo visual de una primitiva se puede pensar en el dibujo de una esfera en un motor grÃ¡fico, mientras que uno no visual puede ser la extracciÃ³n de los lÃ­mites de la esfera, necesario para obtener informaciÃ³n del entorno que luego puede ser transmitido a un agente.

Una transformaciÃ³n es una modificaciÃ³n del comportamiento de las primitivas, la cual se aplica en el mismo sistema geomÃ©trico G. Al igual que la primitiva, se va a considerar la transformaciÃ³n no sÃ³lo como un escalado, un desplazamiento, un giro, etc., sino que va a definir tambiÃ©n una asignaciÃ³n de color, la alteraciÃ³n de un sonido y todo aquello que represente una modificaciÃ³n del comportamiento de las primitivas dentro de G. Las transformaciones tienen un Ã¡mbito de aplicaciÃ³n y sÃ³lo se aplicarÃ¡ al conjunto de primitivas que se encuentren dentro de ese Ã¡mbito, extrayendo, al igual que las primitivas, informaciÃ³n necesaria del entorno.

Por otro lado, se tiene como elemento dinÃ¡mico el agente. Este estÃ¡ compuesto por un conjunto de actividades que representan su evoluciÃ³n a lo largo del tiempo, y un conjunto opcional que define los diferentes estados internos en los que puede hallarse, de los cuales sÃ³lo uno de ellos puede ser seleccionado. Dependiendo del estado seleccionado va a poder ejecutarse un conjunto particular de actividades. Toda actividad consiste en un proceso o funciÃ³n, denominada funciÃ³n de evoluciÃ³n, que se ejecuta como reacciÃ³n a un determinado evento. Este puede ser producido por un dispositivo de entrada o por otra actividad, tanto del mismo agente como de otro. Por tanto, una actividad se compone tanto del proceso de ejecuciÃ³n como del evento o conjunto de eventos que la han activado. Como ejemplos de actividad se tiene la modificaciÃ³n del estado interno del agente (posibilitando que se ejecuten otras actividades), la eliminaciÃ³n de los agentes que se sitÃºan a su alrededor, o el movimiento del agente en el escenario dado.

El concepto de evento dentro de un agente es importante, ya que define cuÃ¡ndo se va a ejecutar la actividad ademÃ¡s de definir unos datos asociados necesarios para la actividad. Por ejemplo, un evento de movimiento puede generarse cuando se mueve un ratÃ³n con los datos del movimiento. La generaciÃ³n del evento va a ser independiente del dispositivo de entrada. Es decir, se separara el dispositivo de la actividad que se debe procesar. Por ejemplo, el evento de movimiento se puede generar tambiÃ©n al pulsar el teclado o como resultado de una decisiÃ³n tomada por un agente. AdemÃ¡s, los eventos van a ser la vÃ­a por el cual se va a definir las diferentes formas de comunicaciÃ³n que puede existir en un SMA (comunicaciÃ³n entre agente-agente y entre agente-entorno).

No toda actividad tiene porquÃ© ejecutarse siempre cuando se envÃ­a un evento. Pueden existir determinados eventos que ejecuten la actividad sÃ³lo si se cumplen ciertas condiciones, entre ellas el estado interno del agente.
	
\begin{table}[h]
\begin{center}
\begin{tabular}{|l|}
    \hline

    Rule 1.- \textbf{WORLD} $\rightarrow$ OBJECTS \\

    Rule 2.- \textbf{OBJECTS} $\rightarrow$ OBJECT $|$ OBJECT Â· OBJECTS \\

    Rule 3.- \textbf{OBJECT} $\rightarrow$ FIGURE $|$ TRANSFORMATION $|$ AGENT \\

    Rule 4.- \textbf{AGENT} $\rightarrow$ $a^d_s$ (OBJECTS), $a^d_s \in \textbf{A}^D_S, d \in D, s \in S$ \\

    Rule 5.- \textbf{TRANSFORMATION} $\rightarrow t$ (OBJECTS), $t \in T$ \\

    Rule 6.- \textbf{FIGURE} $\rightarrow$ $p^+$, $p \in P$ \\

    \hline
\end{tabular}
\end{center}
\label{tab:rules}
\caption{Grammar rules $R^*$}
\end{table}
	
	
A string $w \in \Sigma^*$ is generated by the grammar $M$ if it can be
obtained starting with the initial symbol WORLD and using the rules of the
grammar. The language generated by the grammar $M$ is the set of all the strings
which can be generated by this method. This language is called $L(M)$ and is
defined as:

\begin{equation}
 L(M) = \lbrace w \in \Sigma^* \ | \ \text{WORLD} \stackrel{*}{\rightarrow} w \rbrace
\end{equation}


The grammar $M$ is a context-independent grammar (or a type-2 grammar, according to the Chomsky
hierarchy). Therefore, there is a procedure which verifies if a scene is correctly described or, in
other words, if a string belongs to the language $L(M)$ or not. For example, it can be determined
that the string $a_1^d ( p_1 \cdot p_2) \cdot p_3 \cdot t_1 ( p_1 \cdot p_2 ) \in L(M)$ where $p_i
\in P$, $t_i \in T$, $a_i^d \in A^D_S$, but, on the contrary, $a_1^d \cdot p_1 \notin L(M)$.

Apart from the language syntax, it is necessary to define the functionality of the strings, that is,
the semantics of the language. It can be denoted through three methods: operational, denotational and axiomatic. In our case, the denotational method is used. It The defines the meaning of the string through mathematical logic terms.


%___________________________________________________________________________
\subsection{Semantics of the Language $L(M)$
\label{sec:semantic}}

In this section, a mathematical function is assigned to each rule of Table 1.


%___________________________________________________________________________
\subsubsection{Semantic Function for Primitives (Rule 6)
\label{sec:rule6}}

Rule 6 defines the syntax of a figure as a sequence of primitives. Primitive's semantics is defined
as a function $\alpha$. Each symbol in the set $P$ carries out a primitive on a given geometric
system $G$. Therefore, the function $\alpha$ is an application defined as:	
	
\begin{equation}
    \alpha: P \rightarrow G
\end{equation}
	
So, depending on the definition of the function $\alpha$ and on the geometric system $G$, the result of the system may be different. $G$ represents the actions which are run on a specific geometric system. A usual example of geometric system are graphical libraries, such as OpenGL or Direct3D. In this
case, each symbol of $P$ would have associated an action of the render system. For instance, given
the symbol of a sphere ($sphere \in P$), it would implement a function which draws this object in
the corresponding graphics system (Direct3D or OpenGL):	
	
\[ \begin{matrix}
    \alpha_{opengl}(sphere) = glutSolidSphere \\
    \alpha_{direc3d}(sphere) = drawSphereDirect3D
\end{matrix} \]

These functions are examples of visual geometric systems. But this definition can also be extended
to non-visual geometric systems. For example, a non-visual system could be the calculation of the
boundaries of a figure, which could be used to calculate collisions between elements. So, a new
function $\alpha_{bounds}(sphere) = boundSphere$ can be defined for the same alphabet $P$, where
``\textit{boundSphere}'' is a function which calculates the limits of spheres.
	
Previous examples show that the function $\alpha$ provides the abstraction needed to homogenize the different implementations of a render system. Therefore, only a descriptive string is needed to run the same scene on different graphics systems. ************ Esto sobre todo es importante para relacionar los agentes con el motor fÃ­sico. Los procesos de extracciÃ³n de la informaciÃ³n del entorno se ejecutan en mÃ³dulos geomÃ©tricos y componen el motor fÃ­sico de un SG. La informaciÃ³n procesada es enviada a los agentes lo suficientemente tratada como para que estos puedan realizar su actividad usando solo los elementos del motor fÃ­sico.
	
So far, only Euclidean geometric systems have been considered. But, the function $\alpha$ has no
restrictions on the geometric system that can be applied as long as there is a definition for this
primitive. Thus, it could also implement a sound, the movement of a robot, the reflection of a
material and so on. Moreover, the definition of the function $\alpha$ could also describe systems
to send strings in a network, which is very important in a MAS.
	
	
%___________________________________________________________________________
\subsubsection{Semantic Function for Transformations (Rule 5)
\label{sec:rule5}}
	
Rule 5 defines the syntax for transformations. The scope of a transformation is
limited by the symbols ``()''. Two functions are used to describe the semantics
of a transformation. These functions are:

\begin{center}
\begin{tabular}{l}
    $\beta: T \rightarrow G$ \\
    $\delta: T \rightarrow G$
\end{tabular}
\end{center}

$\beta$ represents the beginning of the transformation. It is carried out when the symbol ``('' is
processed and it has to take into account the previous symbol of the set $T$. The function $\delta$
defines the end of the transformation which has previously been activated by the function $\beta$.
It is carried out when the symbol ``)'' is found.

These two functions have the same features that the function $\alpha$, but they
are applied to the set of transformations $T$, using the same geometric system
$G$.

A new function $\varphi$ is defined using the set of primitives $P$, the set
of transformations $T$ and the functions $\alpha$, $\beta$ and $\delta$. Given a
string $w \in L(M)$ and using only symbols of $P$ and $T$, this function
$\varphi$ runs the sequence of primitives and transformations in the geometric
system $G$. It is defined as:

\begin{equation}
    \varphi (w) = \left\{
    \begin{array}{ll}
        \alpha(w) & \mathit{if} \ \ w \in P  \\

        \beta(t); \varphi(v); \delta(t) & \mathit{if} \ \ w = t(v)
\wedge v \in L(M) \\

        \varphi(s); \varphi(t)  & \mathit{if} \ \ w = s \cdotp t \wedge
s, t \in L(M)
    \end{array}\right\}
\end{equation}


One of the most important features of this system is the independence on specific graphics
system. The definition of the functions $\alpha$, $\beta$ and $\delta$ provides the differences in
behaviour. These functions encapsulate the implementation details which may differ for different
systems, such as a render system, a geometric calculation system, a command execution system in a
production chain, and so on. Therefore, in the development of strings to define virtual worlds is
not necessary to consider the special features of the geometric system. In addition, these strings 
may be used on all the systems which implement these functions.

	

%___________________________________________________________________________
\subsubsection{Semantic Function for Agents (Rule 4)
\label{sec:rule4}}

Rule 4 of the grammar $M$ refers to agents, which are the dynamic part of the system and the elements that compose a MAS. The semantics of agents is a function which defines its evolution in time. For this reason, the semantic function is called \textit{evolution function} $\lambda$ and it is defined as:

\begin{equation}
    \lambda: L(M) \times E^D \rightarrow L(M)
\end{equation}

where $E^D$ is the set of events for the device $D$ ****************(considerando estos dispositivos como cualquier proceso software o hardware que emite eventos) and the strings $w \in L(M)$ fulfill the
syntactic rule 4. The function $\lambda$ can be interpreted as the evolution of the agent in time, ****************** ya que si w representa un agente, al aplicar la funciÃ³n Î»(w,ef), w se transforma en otra cadena u, lo que nos permite hacer evolucionar el sistema. $\lambda$ has a different expression depending on its evolution. However, the general expression can be defined as:

\begin{equation}
    \lambda (a^{d}(v),e^{f})=
    \left\{
    \begin{array}{ll}
        u \in L(M) & \mathit{if}  \ \ f = d \\
        a^{d}(v)  & \mathit{if}  \ \ f \neq d
    \end{array}\right\}
\end{equation}


The result of the function $\lambda$ may contain or not the own agent, it can generate other
event for the next stage (or the next frame) or change the state 's' of the agent. So, an agent can become a generator of events. The new events generated by agents are accumulated to be passed to the next stage of the system
evolution. In this way, the communication between agents can be modeled, as well as the communication between agents and environment, so important in a MAS. In the case that the event does not match with the triggering event, then this function returns the same agent, and the string remains unchanged. 

The function $\lambda$ can define a recursive algorithm which, given a set of
events and a string, describes the evolution of the system at a given point
in time. This function is called \textit{function of the system evolution} and
it is represented by $\eta$. Its definition requires a set of events
$e^i, e^j, e^k, \dots, e^n$, which in short is denoted as $e^v$, where $v
\in D^+$. This algorithm is defined as:

\begin{equation}
    \eta (w, e^v) = \left\{
    \begin{array}{ll}
        w   & \mathit{if}  \ \ w \in P  \\

        t(\eta (v, e^v))    & \mathit{if}  \ \  w = t(v)  \\

        \underset{\forall f \in v}{ \prod }(\lambda (a^d (\eta
            (y, e^v)), e^f))    & \mathit{if}  \ \ w = a^d(y)
\\

        \eta (s, e^v) \cdot \eta (t, e^v)   & \mathit{if}  \
\  w = s \cdot t
    \end{array}\right\}
\end{equation}

The operator $\underset{\forall f \in v}{ \prod }(\lambda (a^d (\eta (y, e^v)), e^f))$ concatenates
the strings generated by the function $\lambda$. It is important to note that the strings which are
only composed of transformations and primitives are not processed. Therefore, these strings are not
part of the system evolution, so they are only part of the environment that can be analyzed by agents.
	
The functions $\lambda$ can be classified in accordance with the strings which are obtained during
the evolution of the system. One important type of $\lambda$ functions are those which return
strings with only primitives and transformations, because they are essential to define the
visualization of strings. As it was explained before, the functions $\alpha$, $\beta$ and $\delta$ do
not admit strings with agents. Therefore, agents must be first converted into strings made up only
of primitives and transformations. This conversion is carried out by a type of function $\lambda$
called \textit{visualization function}, or function $\theta$, which is defined as:


\begin{equation}
    \theta: L(M) \times E^V \rightarrow L(E)
\end{equation}


where $V \subseteq D$, $E^V$ are events created in the visualization process, and $L(E)$
is the language $L(M)$ without agents. The expression of the visualization function is defined as:


\begin{equation}
    \theta (a^d(v), e^f) =
    \left\{
    \begin{array}{ll}
        u \in L(E) & \mathit{if}  \ \ f = d \wedge d \in V \\
        \epsilon  & \mathit{if}  \ \ f \neq d
    \end{array}\right\}
\end{equation}

There are small differences between $\lambda$ and $\theta$. The first one is that $\theta$ returns
strings belonging to $L(E)$. The second is that $\theta$ returns an empty string if the event does
not match. So, the agent will not have representation for that event.

The type of event $V$ (visualization event) does not correspond to any specific input device. It is used 
to create different views of the system. *********************** Este analiza la actual situaciÃ³n del sistema para poder enviar esta informaciÃ³n a los agentes, estableciendo asÃ­ una relaciÃ³n entre los agentes y el motor fÃ­sico. For example, to design a system which filters out certain elements in order that they become invisible, it is only necessary to avoid reacting to those events. Moreover, they can also be used to change the visualization type, depending on the type of window, or on the output device and its features, or they can move a mobile robot through primitives of movement.

As with the function $\lambda$, an algorithm is defined for $\theta$. It returns a string $z \in
L(E)$, given a string $w \in L(M)$ and a set of events $e^v$, where $v \in V^+$ and $V \subseteq
D$. This function is called \textit{function of system visualization} $\pi$ and it is defined as:


\begin{equation}
   \begin{array}{c}
    \pi: L(M) \times E^V \rightarrow L(E) \\
\\
    \pi (w, e^v) = \left\{
    \begin{array}{ll}
        w   & \mathit{if}  \ \ w \in P^+  \\

        t(\pi (y, e^v))     & \mathit{if}  \ \  w = t(y)  \\

        \underset{\forall f \in v}{ \prod }(\theta (a^v (\pi
            (y, e^v)), e^f))    & \mathit{if}  \ \ w = a^v(y)
\\

        \pi (s, e^v) \cdot \pi (t, e^v)    & \mathit{if}  \
\  w = s \cdot t
    \end{array}\right\} \\
   \end{array}
\end{equation}



%___________________________________________________________________________
\subsubsection{Semantic Functions for OBJECT, OBJECTS and WORLD (Rules 1,
2 and 3)
\label{sec:rules123}}
	
The semantic function of these rules breaks down strings and converts them into substrings. The
functions specified above are carried out depending on whether the symbol is an agent, a
transformation or a primitive. Therefore, the semantic function of WORLD is a recursive function
which breaks down the string of the WORLD and converts it into substrings of OBJECTS. Then, these
substrings are in turn broken down into substrings of OBJECT. And for each substring of OBJECT,
depending on the type of the object, the semantic function of AGENT, PRIMITIVE or TRANSFORMATION is
run. ***************** Se debe observar que las primitivas que no son generadas por los agentes con la funciÃ³n de visualizaciÃ³n representan la parte estÃ¡tica del sistema, o lo que es lo mismo, el entorno geomÃ©trico donde se desarrolla la actividad del sistema.



%___________________________________________________________________________
\subsection{Activity and Events
\label{sec:activity_events}}
	
In MAS some mechanisms must be established to model the activity of the system.
This activity can appear during the action of an agent, between several agents with a certain
relationship (for example, an agent which is composed of other agent -which are their children-
and there is some activity between them), and between input devices and scene's strings. Each type
of activity is different, but they have some features in common, and they are going to be
established.
	
As it has been said before, agents activity is carried out when a certain type of event is produced
with some specific data. But not all activities are directly run when an event is received. There
are events that only run its activity when certain conditions are satisfied, depending on the
agent state. This condition is not defined at the object that runs the activity, but at the event.
The following event definition is established:

{\itshape
$e_c^d$ is defined as an event of type $d \in D$ with data $e$, which is carried out only when the
condition $c$ is fulfilled. When there is not any condition, that is, $c = TRUE$, the event is
represented by $e^d$.
}
	
Let us notice that the origin of events is not identified. In fact, the origin is not
important, but the event type and its data. ******************* Esto no quiere decir que en el evento no se puedan incluir datos que identifiquen a quiÃ©n envÃ­a el mensaje. Por ejemplo, en la comunicaciÃ³n entre dos agentes  los eventos pueden contener informaciÃ³n sobre quiÃ©n enviÃ³ el mensaje y quÃ© tipo de dato se envÃ­a. De esta manera se establece un sistema genÃ©rico de comunicaciÃ³n que puede implementar KMQL o FIPA [Genesereth et Al., 1995] o incluso los dos a la vez implementando varios dialectos.
	
	
	
	
%___________________________________________________________________________
\subsection{Input Devices and Event Generators
\label{sec:input_devices}}
	
It is necessary to establish the independence between the system and the input devices (hardware or software), 
considering these input devices such as any process capable of generate events. So, the events needed to make 
the system respond to a set of input devices must be defined. It means that
there may be actions on input devices (buttons, mouse wheel, movements and so on) which generate
one or more events, and others which do not generate any. The input devices need not be only 
physical devices, they may be software devices which, depending on their performance, may or may not
generate events and send the processed information to the agents that compose the scene. 	
It allows to establish a mechanism to provide environment information to agents.
For example, a mouse could be used as input device to move a character in a game. However, there has 
not to be a mouse event associated to the character; instead the mouse has an event generator which
creates generic events of movement which are associated to the character.
*********************** De esta manera se puede generar eventos de movimiento del personaje no sÃ³lo con el ratÃ³n sino con cualquier proceso software que sea necesario siempre y cuando genere el mismo tipo de evento.
On the other hand, an example of software device may be an algorithm
for detecting collisions. In this case, an event can be generated when a collision is detected 	
and send that information to agents who are involved in the collision to establish their reactions.	
	
A new function called \textit{event generator} is defined as:

{\itshape 
Let $C^d(t)$ be a function which creates events of type $d$ at the time instant $t$,
where $d \in D$ and $D$ is the set of event types which can be generated by the system. }	
	

In the previous definition, it should be noticed that events are generated in the time instant $t$.
It is due to synchronization purpose. It is also possible that $C$ does not create any event at a
given moment. The most interesting fact about the implementation of the event generator
is that the device-dependent code is encapsulated and separated from the rest.

One problem is that different event generators can create the same type of events. So, a priority
order among event generators must be established to avoid ambiguities. Given two generators $C_i$
and $C_j$ which create the same event, if $i < j$, then the events generated by $C_i$ will have a
higher priority.

The process which obtains the events produced by input devices and their associated 
generators is defined as follows:



{\itshape

Let $C^*$ be the set of all the event generators which are associated with input
devices.

}


The function $e(z, e^i)$ which concatenates all the events in a list is defined
as:

\begin{equation}
    e(z, e^i) = \left\{
    \begin{array}{ll}
        z \cdot e^i   &   \mathit{if} \ \ e^i \notin z \\
        z    &   \mathit{if} \ \ e^i \in z
    \end{array}
    \right\}
\end{equation}


The function $E(C^*, t)$ collects all the events from all the generators and accumulates them in a
list. If the event $e^i$ already exists, then it is not inserted in the list. This function is
defined as:


\begin{equation}
    E(C^*, t) = \left\{
    \begin{array}{ll}
        e(z, C_i(t))   &  \mathit{if}  \ \ z = E(C^* - C_i, t) \\
        \epsilon   &  \mathit{if} \ \ C^* = \emptyset
    \end{array}
    \right\}
\end{equation}


Tanto con los generadores de eventos como con los eventos que genera los agentes, se puede modelar todo lo relacionado con los procesos de comunicaciÃ³n que existen en los SMA. Para comunicar dos agentes sÃ³lo se debe establecer en la funciÃ³n de evoluciÃ³n los casos en los que el agente genera un evento. Este evento se envÃ­a al siguiente frame dando la posibilidad de que pueda ser recogido por uno o varios agentes. AsÃ­, el agente que originÃ³ el evento puede pasar informaciÃ³n a otros agentes y estos a su vez, con el mismo mecanismo, pueden transmitir mÃ¡s informaciÃ³n al agente origen.

Por otra parte, mediante los generadores de eventos se puede implementar la comunicaciÃ³n necesaria entre los agentes y el entorno: simplemente hay que definir un generador de eventos para cada aspecto que se quiera considerar como informaciÃ³n del entorno y que debe ser transmitida al agente. Por ejemplo, si se define un motor fÃ­sico que va a calcular la gravedad que influye sobre determinados agentes (aquellos que estÃ¡n en el campo gravitatorio), a este motor se le va a definir un generador de eventos que bajo determinadas condiciones va a crear un evento cuya informaciÃ³n contendrÃ¡ todo lo necesario para que los agentes puedan establecer cual va a ser su reacciÃ³n ante esta fuerza de gravedad.



%___________________________________________________________________________
\subsection{System Algorithm
\label{sec:system_algorithm}}


Once all the elements involved in the model to manage a MAS have been defined, the algorithm which carries out the
entire system can be established. It defines the system evolution and its visualization at every
time instant `$t$' or frame. The \textit{Algorithm of Virtual Worlds Generation} is defined as:

		
\begin{center}
\begin{tabular}{|ll|}
    \hline

    Step 1. & $w = w_o$ \\

    Step 2. & $t = 0$ \\

    Step 3. & $e^* = E(G^*, t)$ \\

    Step 4. & $e^v =$ events of $e^*$ where $v \in V^+$ \\

    Step 5. & $e^u = e^* - e^v$ \\

    Step 6. & $w_{next} = \eta(w, e^u)$ \\

    Step 7. & $v =  \pi(w, e^v)$ \\

    Step 8. & $g = \varphi(v)$ \\

    Step 9. & $w = w_{next}; \ \ t = t + 1$ \\

    Step 10. & If $w = \epsilon$ then go to step 12 \\

    Step 11. & Go to step 3 \\

    Step 12. & End \\

    \hline
\end{tabular}
\end{center}


Where:


\begin{itemize}
    \item $D$ = \{ Set of all the types of possible events in the system \}.

    \item $V$ = \{ Set of all the types of visual events \} where $V \subseteq D$.

    \item $G^*$ = \{ All the event generators which generate events of type $D$ \}.

    \item $g$ is the output device.

    \item $e^*$ are all the events generated by the system in a frame $t$.

    \item $e^v$ are all the events from visual devices. These events are one of 
the inputs of the visual algorithm $\pi$.

    \item $e^u$ are all the events from non-visual devices. These events
are the input of the evolution algorithm $\eta$.

    \item $w_o$ is the intial string of the system.
\end{itemize}
	


The first two steps initialize the system. The initial state $w_o$ is
introduced to the system and the first frame is set to 0.

Steps 3, 4 and 5 manage the system events. In Step 3, generators are called to insert all the
events in a list $e^*$. In Steps 4 and 5, events are divided into visual events ($e^v$, which are
the input of the visual algorithm $\pi$) and non-visual events ($e^u$, which are the input of the
evolution algorithm $\eta$).

In Step 6, the evolution algorithm $\eta$ is called with the current string $w$ and the non-visual
events ($e^u$). The output is the string for the next frame or instant $t$.

In Step 7 and 8, the visualization of the system is performed. First, agents are transformed into
primitive and transformations. Next, the visualization algorithm $\pi$ is called with the visual
events ($e^v$). Finally, the function $\varphi$ is called to display the current state of the
system into the render engine $g$.
	
In Step 9, the next iteration is prepared. $w$ is assigned to $w_{next}$ and the time instant (or
current frame) is increased in 1.

Step 10 checks if the current string satisfies the condition of completion, that is, if the
following string is empty, then the algorithm ends (Step 12). Otherwise, the algorithm goes to Step
3. Therefore, to finish the main algorithm the function $\alpha$ must just return an empty string.
This empty string can be generated by a special event which is created when the system must stop.

It must be noticed that Step 6 can be exchanged with Steps 7 and 8, because they do not share any
data. This feature is very important for the parallel implementation of the algorithm. So, Step 6
and Steps 7 and 8 can be divided into two parallel tasks. This type of optimization has a
significant impact on the final graphics system, which leads to a faster system performance.
	
This formalization of the system has two main consequences. First, the scene definition is
separated from the hardware-dependent characteristics of components. The functions $\alpha$,
$\beta$ and $\delta$ provide the independence from the visualization system, and the event
generators provide the independence from the hardware input devices. Secondly, due to the fact that
there is a specific scheme to define the features of a system, the different system elements can be
reused easily in other areas of application.
	
	
	
%___________________________________________________________________________
\section{Case of Study
\label{sec:case_study}}
%___________________________________________________________________________

This section describes a case of study which shows the steps to define a system using the proposed
model. This example is an application that simulates fires in forests caused by lightning. It could
be used to analize the best distribution of trees to reduce the number of burnt trees
\cite{John2007}.

El sistema, bÃ¡sicamente, consiste en un agente que define lo que se denomina el bosque, el cual genera agentes que implementan Ã¡rboles y relÃ¡mpagos. En primer lugar se realiza una descripciÃ³n detallada del problema que se desea resolver mediante SMA, para luego definir todos los componentes con el modelo formal especificado.


%___________________________________________________________________________
\subsection{Problem description
\label{sec:description_problem}}
%___________________________________________________________________________

*********** El problema consiste en la representaciÃ³n de un mundo, donde cada cierto tiempo crece un Ã¡rbol con una cierta probabilidad g. El crecimiento de un Ã¡rbol hace que este se sitÃºe en un determinado lugar (i,j) de un tablero 2D. 
***********
Bolts of lightning can also fall on a $(i, j)$ position
with a probability $f$. In this case, if there is a tree, it will burn as well as
the trees around it, in a chain reaction.

To model this example with the proposed model, four main elements need to be defined.
First, it is necessary to define events for the system to run agent activities. These events
include the necessary information to develop their activity. Second, it is necessary to design
event generators that separate the interactive system from the origin of the events (mouse, keyboard, and
so on). Third, it is necessary to define the agents included in the scene. These elements are
required for the system to evolve over time. Last, the graphic primitives must be defined to show 
the visual elements on the render system.
	


%___________________________________________________________________________
\subsection{Formalization of the system
\label{sec:formalization_system_model}}
%___________________________________________________________________________

Following the steps described above, the different elements of the system are defined.

Events are used to produce the necessary activity of system. They are described by an
identifier and a set of data. Their aim is to produce certain activities of the agents that
compose the scene. The events defined for this example are shown in table \ref{table1}.

\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|p{0.1\linewidth}|p{0.35\linewidth}|p{0.35\linewidth}|}

    \hline
    \itshape Type of event &
    \itshape Meaning &
    \itshape Associated data\\

    \hline
    $t$ &
    Event generated every time instant $t$
    &
    Increasing time since previous event\\

    \hline
    $c$ &
    Create a tree at a given position &
    Position (i,j) where the tree is created \\

    \hline
    $f$ &
    Create a bolt of lightning at a given position &
    Position (i,j) where the bolt of lightning is created\\

    \hline
    $e$ &
    Eliminate the tree at a given position &
    Position (i,j) where the tree is eliminated\\

    \hline
    $b$ &
    Burn the tree at a given position &
    Position (i,j) where the tree to be burned is\\

    \hline
    $v$ &
    Draw using a graphics library (e.g. OpenGL) &
    Void\\

    \hline

\end{tabular}
\end{small}
\caption{\label{table1} Events definition}
\end{center}
\end{table}


The next step is to define the event generators:

\begin{enumerate}

\item Time event generator: 
This generator, named by $C_{time}$, has the responsibility of animating the system. Every time
instant $t$, it generates an event $e^t$ that is usually associated with some type of primitive
transformation to change the appearance of an agent over time.

\item Forest event generator:
This generator produces events to create trees and lightning. Taking into account the
previous specification, trees are created with a probability $g$ and lightning with a probability
$f$. This generator is defined as:

\[C_{forest}=
    \left\{
        \begin{matrix}
            e^{c} & with \ probability \ g \\
            e^{f} & with \ probability \ f
        \end{matrix}\right\}\\
\]

\item Visualization event generator:
This generator is necessary to visualize all the elements in the scene. This means that every
instant time a drawing order is received, the generator captures this order and produces an 
event, sending the draw elements of the scene to the graphics system. Its mathematical expression
is given as:

\[C_{visualization} = \{ e^o \ \mathit{each \ drawing \ cycle} \} \]
\end{enumerate}


The primitives and transformations that make up the scene are shown in tables \ref{table2} and
\ref{table3}:

\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|l|l|}

	\hline \itshape Primitive & \itshape Description\\
	\hline TR & Draw a tree\\
	\hline TRB & Draw a burning tree\\
	\hline FA & Draw a bolt of lightning\\
	\hline BO & Draw a grid of NxN \\
	\hline

\end{tabular}
\end{small}
\caption{ \label{table2} Definition of primitives}
\end{center}
\end{table}


\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|l|l|}

	\hline \itshape Transformations & \itshape Description\\
	\hline $D_{i,j}$ & Translate (i,j)\\
	\hline $S_{s}$ & Scale (s)\\
	\hline

\end{tabular}
\end{small}
\caption{\label{table3} Definition of transformations}
\end{center}
\end{table}


The functions ${\alpha}$, ${\beta}$ and ${\delta}$ define these primitives and transformations 
and they are implemented with a graphics library (in this case OpenGL). This way, the number of 
primitives and transformations can be easily extended just implementing them in the functions 
${\alpha}$, ${\beta}$ and ${\delta}$.


The last step is to specify the agents which compose the dynamic part of the system. As explained in previous sections, an agent is defined by its evolution function $\lambda$. If it has a graphical representation, it also uses the function $\pi$ to generate the primitives and the transformations needed to create that representation. Table \ref{table4} shows the agents defined for this example and their evolution function.

\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|p{0.05\linewidth}|p{0.17\linewidth}|p{0.6\linewidth}|}
%{|l|l|l|}
%{|p{1cm}|p{2.6cm}|p{2.6cm}|}

	\hline 
	\itshape Agent & \itshape Description & \itshape Function ${\lambda}$\\
	\hline

	$B^{cfe}$ & Represents the forest &
	$\lambda
	(B^{\mathit{cfe}},e^{i})=\left\{\begin{matrix}\mathit{TG}^{t}\cdot
	B^{\mathit{cfv}}\hfill\null &i=c\hfill\null \\F^{t}\cdot
	B^{\mathit{cfv}}\hfill\null &i=f\hfill\null
	\\B^{\mathit{cfe}}\hfill\null &i=e\hfill\null
	\\B^{\mathit{cfe}}\hfill\null &f\neq c,r,v\hfill\null
	\end{matrix}\right\}$ \\

	\hline

	$TG^{t}$ & Represents the growth of a tree &
	$\lambda
	(\mathit{TG}^{t},e^{i})=\left\{\begin{matrix}\mathit{TG}^{t+1}\hfill\null
	&i=t\wedge t+1\leqslant N_{\mathit{frames}}\hfill\null
	\\T^{b}\hfill\null &i=t\wedge t+1>N_{\mathit{frames}}\hfill\null
	\\\mathit{TG}^{t}\hfill\null &i\neq t\hfill\null \end{matrix}\right\}$ \\

	\hline

	$T^{b}$ & Represents a tree &
	$\lambda (T^{b},e^{i})=\left\{\begin{matrix}\mathit{TB}^{t}\hfill\null
	&i=b\hfill\null \\T^{b}\hfill\null &i\neq b\hfill\null
	\end{matrix}\right\}$ \\

	\hline

	$F^{t}$ & Represents the animation of a bolt of lightning  &
	$\lambda (F^{t},e^{i})=\left\{\begin{matrix}F^{t+1}\hfill\null
	&i=t\wedge t+1\leqslant N\hfill\null \\\Delta e^{b}\hfill\null
	&i=t\wedge t+1>N_{\mathit{frames}}\hfill\null \\F^{t}\hfill\null &i\neq
	t\hfill\null \end{matrix}\right\}$ \\

	\hline

	$TB^{t}$ & Represents a burning tree &
	$\lambda
	(\mathit{TB}^{t},e^{i})=\left\{\begin{matrix}\mathit{TB}^{t+1}\hfill\null
	&i=t\hfill\null \\\Delta e^{e}\hfill\null &i=t\wedge
	t+1>N_{\mathit{frames}}\hfill\null \\\mathit{TB}^{t}\hfill\null &i\neq
	t\hfill\null \end{matrix}\right\}$ \\
	\hline

\end{tabular}
\end{small}
\caption{\label{table4} Agents defined for this example}
\end{center}
\end{table}



Agent $B^{cfe}$ represents the forest. This agent generates a tree or a bolt of lightning, if it receives the event $e^{c}$, the event $e^{f}$ respectively. The agents generated by these events are introduced in the string at next fame. These agents are $TG^{t}$ and $F^{t}$. The event $e^{e}$ only changes the internal state of the agent $B^{cfe}$. It frees its position ($i, j$), so a new tree may grow in the same position.

Por otro lado, estÃ¡ el agente que define un Ã¡rbol. Tiene tres estados internos S = {c, a, i}. El estado 'c' corresponde al estado de crecimiento del Ã¡rbol, el estado 'a' corresponde al Ã¡rbol ya crecido o en estado adulto y el estado 'i' es el estado del Ã¡rbol incendiÃ¡ndose. Este agente reacciona a los eventos et que se utilizan para hacer las animaciones y eq que cambian el estado del Ã¡rbol a incendiado. De la funciÃ³n de evoluciÃ³n de este agente se puede destacar la transiciÃ³n entre estados que tiene el agente dependiendo del evento. Por ejemplo, cuando se termina la animaciÃ³n del Ã¡rbol creciendo (segunda linea de la funciÃ³n) se puede observar como el agente pasa del estado 'c' al estado 'a'. Otro caso de cambio de estado es cuando el agente recibe un evento eq y pasa del estado 'a' al estado 'i'. AdemÃ¡s de cambiar de estado, se ejecuta una funciÃ³n Vecinos que lanza a cada Ã¡rbol vecino un evento de quemado eq.

$F^{t}$ is similar to $TG^{t}$, unless it creates a bolt of lightning. When the animation ends, it generates an event $e^{b}$ that burns the tree.

Tanto la llamada de un Ã¡rbol a Vecinos para enviar a un evento eq a cada uno de sus vecinos, como cuando un relÃ¡mpago termina su animaciÃ³n y manda el evento eq al Ã¡rbol donde estÃ¡ el relÃ¡mpago, son dos ejemplos de comunicaciÃ³n entre agentes. En el caso de que un relÃ¡mpago mande un evento eq a una posiciÃ³n en la que no hay ningÃºn Ã¡rbol, este evento no procesarÃ¡ ninguna actividad. Otro tipo de comunicaciÃ³n es el que se establece entre el bosque y el generador Cbosque para modificar el entorno, en este caso el bosque crea Ã¡rboles o relÃ¡mpagos.

Table \ref{table5} shows the definition of the drawing function $\pi$. This function is used to obtain the set of primitives and transformations representing the visual aspect of an agent, which is shown on the display.


\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|l|l|}

    \hline \itshape Agent & \itshape Function ${\pi}$ \\
    \hline
    $B^{v}$ &
    $\pi (B^{v},e^{i})=\left\{\begin{matrix}\mathit{BO}\hfill\null
        &i=v\hfill\null \\\epsilon \hfill\null &i\neq v\hfill\null
        \end{matrix}\right\}$   \\

    \hline
    $TG^{v}$ &
    $\pi (\mathit{TG}^{v},e^{i})=\left\{\begin{matrix}D_{(i,j)}(S_{s}(\mathit{TR}))\hfill\null
        &i=v\hfill\null \\\epsilon \hfill\null &i\neq v\hfill\null
        \end{matrix}\right\}$   \\

    \hline
    $T^{v}$ &
    $\pi(T^{d},e^{i})=\left\{\begin{matrix}D_{(i,j)}(\mathit{TR})\hfill\null
        &i=v\hfill\null \\\epsilon \hfill\null &i\neq v\hfill\null
        \end{matrix}\right\}$   \\

    \hline
    $F^{v}$ &
    $\pi(F^{d},e^{i})=\left\{\begin{matrix}D_{(i,j)}(\mathit{FA})\hfill\null
        &i=v\hfill\null \\\epsilon \hfill\null &i\neq v\hfill\null
        \end{matrix}\right\}$   \\

    \hline
    $TB^{v}$ &
    $\pi(\mathit{TB}^{v},e^{i})=\left\{\begin{matrix}D_{(i,j)}(S_{s^{-1}}(\mathit{TRB}))\hfill\null
        &i=v\hfill\null \\\epsilon \hfill\null &i\neq v\hfill\null
        \end{matrix}\right\}$   \\

    \hline
\end{tabular}
\end{small}
\caption{\label{table5} Definition of the drawing function}
\end{center}
\end{table}



$S$ represents a growing scale factor which depends on the current state of the agent $TG$. This state is modified by the event $e^{t}$. It causes the effect of tree's growth. The scale value is defined by the expression $s = t / N$, where $N$ is the total number of frames and $t$ is the current instant of time. However, in the case of $TB$ the scale factor is defined as a decreasing scale $s^{-1}$. It causes the effect of a burning tree, which is getting smaller. 	
This is an example of how an agent can have different representation depending on its internal state.

The animation of a bolt of lightning is implemented by an algorithm which depends on the instant of time $t$. In general, agents' animations always depend on $t$. It modifies the current state of the agent to change its representation and thus perform the animation.

Finally, the initial string is defined. It is the first string to be processed in the algorithm. From this initial state, the system evolves over time. In this example, it is defined as:

\[w_{0}=B^{cfe}\]	
	
	
	


%___________________________________________________________________________
\section{Conclusions and Future Work
\label{sec:conclusions}}
%___________________________________________________________________________

En el presente artÃ­culo se ha propuesto unificar las caracterÃ­sticas mÃ¡s sobresalientes de los SMA y SG. Para ello se ha definido un lenguaje especificado mediante gramÃ¡ticas independientes del contexto que determinan los elementos que componen el sistema. Se han establecido determinadas funciones que representan la evoluciÃ³n de cada uno de los agentes a travÃ©s del tiempo y se han definido funciones que extraen la representaciÃ³n grÃ¡fica de los agentes. Esta representaciÃ³n se envÃ­a a los dispositivos geomÃ©tricos, visuales o no, mediante funciones que separan la implementaciÃ³n concreta sobre un dispositivo geomÃ©trico y la descripciÃ³n geomÃ©trica del agente.

La separaciÃ³n de los dispositivos de entrada, tanto hardware como software, de la definiciÃ³n del sistema se ha articulado a travÃ©s de los generadores de eventos, que levantan una capa entre el dispositivo y la representaciÃ³n del sistema. De esta manera ademÃ¡s se aÃ±ade interactividad con la cadena en evoluciÃ³n.
Se ha diseÃ±ado un sistema de comunicaciÃ³n entre los procesos geomÃ©tricos que definen un motor fÃ­sico y los agentes que componen una escena. El componente que articula esta comunicaciÃ³n es el generador de eventos. Este generador puede aprovechar el hardware dedicado para motor fÃ­sico o implementar la funcionalidad necesaria mediante software. Una vez que se ha tratado y clasificado la informaciÃ³n, se envÃ­a a los diferentes agentes mediante eventos para que reaccionen a la informaciÃ³n generada por el motor fÃ­sico. Por ejemplo, si se quiere que un agente reaccione ante una colisiÃ³n, el generador de eventos de este tipo calcularÃ¡ las colisiones de los elementos extrayendo la geometrÃ­a de la escena gracias al motor grÃ¡fico (utilizando la implementaciÃ³n de las funciones Î±, Î², Î´ para calcular los cubos envolventes de los elementos) y generando los eventos necesarios para las colisiones.

	Las funciones de evoluciÃ³n de los agentes son los elementos necesarios para implementar todas las caracterÃ­sticas requeridas por un SMA. En estas funciones es donde cada agente va a tomar sus decisiones dependiendo de su estado actual, va a comunicarse con otros agentes generando eventos y va a poder observar su entorno gracias al motor fÃ­sico implementado mediante generadores de eventos. Mediante eventos se pueden ejecutar actividades que cambien el estado del agente y que modifiquen su comportamiento. AdemÃ¡s, como el propio agente puede generar eventos, es posible diseÃ±ar los procesos de comunicaciÃ³n utilizados en SMA. TambiÃ©n queda garantizada la integraciÃ³n entre motor fÃ­sico y SMA, ya que estos dos motores se relacionan entre sÃ­ mediante los eventos.
El uso de un lenguaje para la descripciÃ³n de los elementos de la escena y la independencia del sistema grÃ¡fico hace que estas cadenas descriptivas puedan ser reutilizadas en cualquier otro sistema, siempre y cuando estÃ©n implementados los elementos bÃ¡sicos (todas las funciones semÃ¡nticas explicadas en la secciÃ³n 4).

	Este modelo abre diferentes expectativas que podrÃ¡n ser exploradas en el futuro. Por ejemplo, el desarrollo de agentes que estÃ©n compuestos por otros agentes. El lenguaje L(M) deja abierta la posibilidad de definir agentes como rbj(siÂ·tr), con r,s,t â AD. Esto significa que el agente r estÃ¡ compuesto por dos agentes mÃ¡s. Los eventos que recibe r podrÃ­an pasar a 's' y 't' o no, o incluso r podrÃ­a pasar otros eventos diferentes dependiendo de los que recibiera Ã©l. Esto define una dependencia entre agentes. Pero esta dependencia puede crearse en tiempo de ejecuciÃ³n del sistema. Por ejemplo, si se supone que se tiene la cadena rbÂ·sq, con r y s como agentes, se podrÃ­a desarrollar una dependencia entre r y s, de tal manera que, si se produce un determinado evento, la cadena anterior quede como rb(sq). Esto podrÃ­a significar que dos agentes que antes existÃ­an independientemente ahora podrÃ­an formar un sÃ³lo agente. Este tipo de operaciones son muy interesantes ya que recuerdan a procesos de agregaciÃ³n celular. AsÃ­ se podrÃ­an desarrollar algoritmos que de forma espontÃ¡nea, y dependiendo de determinadas condiciones, se pase de organismos unicelulares (cuando los agentes son independientes entre sÃ­) a organismos multicelulares.
	
	Prosiguiendo con las similitudes biolÃ³gicas tambiÃ©n se podrÃ­an estudiar el desarrollo de algoritmos genÃ©ticos. En este caso, dado un agente como rabc, se podrÃ­a definir una funciÃ³n de evoluciÃ³n que dado un evento (que representarÃ­a la reproducciÃ³n), pueda producir la reproducciÃ³n de r pero con modificaciones en la cadena de eventos a los que pueda reaccionar. Es decir, se podrÃ­a reproducir como la cadena  rab o incluso incluir otros eventos como rabd.
	
	TambiÃ©n se podrÃ­a considerar la posibilidad de ejecutar acciones asociadas a eventos pero con una cierta probabilidad. Es decir, si se define un agente como rab y este agente recibiera el evento ea la funciÃ³n asociada a la ejecuciÃ³n de este evento se ejecutarÃ­a pero sÃ³lo con una cierta probabilidad. Esto podrÃ­a servir para algoritmos que utilicen la probabilidad como elemento fundamental en su funciÃ³n de evoluciÃ³n. Por ejemplo, se podrÃ­an usar definiciones de aprendizaje de un agente mediante sistemas probabilÃ­sticos.
	
	Una posible Ã¡rea de aplicaciÃ³n del modelo podrÃ­a ser la robÃ³tica, en la cual existe un uso exhaustivo de los SMA.  Un robot puede comportarse como un agente o un conjunto de agentes y, tanto su representaciÃ³n como sus acciones, se podrÃ­an especificar como un conjunto de primitivas que hacen que el robot se mueva hacia diferentes lugares. Por ejemplo, una acciÃ³n de nuestro sistema puede ser âmueve brazoâ. Esta primitiva puede mover un brazo virtual si hablamos de una simulaciÃ³n grÃ¡fica, o mover un brazo robÃ³tico real. Los diferentes sensores pueden definir un generador de eventos que tratarÃ­an la seÃ±al del sensor y pasarÃ­an a los agentes la informaciÃ³n que necesitan.
En definitiva, se ha pretendido dar una soluciÃ³n que integra lo mejor de los SMA y SG y cuya aplicaciÃ³n puede aplicarse en toda la gran diversidad de problemas que intenta abordar los SMA, con el enriquecimiento que supone usar los SG para el anÃ¡lisis de los datos que genera los agentes en la evoluciÃ³n de un sistema con agentes de diversa naturaleza.












\begin{thebibliography}{0}

\bibitem[PhyX]{Physx}
PhysX by AGEIA:
http://physx.ageia.com

\bibitem[DJK05]{David2005}
David J.~Kasik William~Buxton D. R.~F.:
Ten cad challenges.
IEEE Computer Graphics and Applications 25 (2005), 81--90

\bibitem[WMod]{WModel}
Working Model: Simulaci\'on de Sistemas:
http://www.design-simulation.com

\bibitem[DW94]{Davis1994}
Davis Martin D.;~Sigal R., Weyuker E.~J.:
Computability, Complexity, and Languages, Fundamentals of Theoretical Computer
Science, 2nd~ed.
San Diego: Elsevier Science, 1994

\bibitem[NGDy]{NGDynamics}
Newton Game Dynamics:
http://www.newtondynamics.com

\bibitem[ODEn]{ODE}
Open Dynamics Engine:
http://www.ode.org

\bibitem[WPEn]{Wikipedia2007}
Wikipedia - Physics engine:
http://en.wikipedia.org/wiki/physics\_engine

\bibitem[Havok]{Havok}
Havok:
http://www.havok.com

\bibitem[JHM07]{John2007}
John H.~Miller S. E.~P.:
Complex Adaptative Systems.
Princeton University Press, 2007

\bibitem[Joshua2004]{Joshua2004}
Joshua~Strickon J. A.~P.:
Emerging technologies.
Siggraph (2004)

\bibitem[PALay]{PAL}
PAL: Physics Abstraction Layer:
http://www.adrianboeing.com/pal/

\bibitem[DirX]{DirectX}
PÃ¡gina oficial de DirectX:
http://www.microsoft.com/windows/directx/default.mspx

\bibitem[OpGL]{OpenGL}
PÃ¡gina oficial de OpenGL:
http://www.opengl.org/

\bibitem[SDLay]{SDL}
Simple DirectMedia Layer (SDL):
http://www.libsdl.org

\bibitem[OGRE]{OGRE}
OGRE 3D: Open source graphics engine:
http://www.ogre3d.org

\bibitem[VTK]{VTK}
The Visualization ToolKit (VTK):
http://public.kitware.com/vtk

\bibitem[EOECF]{EOECF}
EO Evolutionary Computation Framework:
http://eodev.sourceforge.net

\bibitem[CILib]{CILib}
CILib (Computational Intelligence Library):
http://cilib.sourceforge.net

\bibitem[wiiNintendo]{wiiNintendo}
Wii-Nintendo:
http://www.nintendo.es

\bibitem[Jade]{Jade}
Jade - Java Agent DEvelopment Framework:
http://jade.tilab.com

\bibitem[Lai01]{Laird2001}
Laird J.~E.:
Using a computer game to develop advanced ai.
Computer 34 (7) (2001), 70--75

\bibitem[GNY04]{Georgios2004}
Georgios N.~Yannakakis John~Levine J.~H.:
An evolutionary approach for interactive computer games.
In Proceedings of the Congress on Evolutionary Computation (2004), 986--993.

\bibitem[CM07]{Chris2007}
Chris~Miles Juan~Quiroz R. L. S. J.~L.:
Co-evolving influence map tree based strategy game players.
IEEE Symposium on Computational Intelligence and Games (2007), 88--95

\bibitem[RGR05]{Robert2005}
Robert G.~Reynolds Ziad~Kobti T. A. K. L. Y. L.~Y.:
Unraveling ancient mysteries: Reimagining the past using evolutionary
  computation in a complex gaming environment.
IEEE transactions on evolutionary computation 9 (2005), 707--720

\bibitem[Woo97]{Wooldridge1997}
Wooldridge M.:
Agent-based software engineering.
IEEE Proceedings Software Engineering 144 (1997), 26--37.

\bibitem[WD00]{Wood2000}
Wood M.~F., DeLoach S.:
An overview of the multiagent systems engineering methodology.
AOSE (2000), 207--222

\bibitem[Ken06]{Kenyon2006}
Kenyon S.~H.:
Behavioral software agents for real-time games.
IEEE Potentials 25 (2006), 19--25

\bibitem[AK02]{Aaron2002}
Aaron~Khoo R.~Z.:
Applying inexpensive ai techniques to computer games.
IEEE Intelligent Systems 17(4) (2002), 48--53

\end{thebibliography}



\end{document}
