\documentclass[runningheads]{llncs}

\usepackage{amssymb}
\usepackage{amsmath}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
%\usepackage[spanish]{babel}
\usepackage{url}


\begin{document}

\mainmatter


\title{Sistemas Multiagentes en Realidad Virtual}
\titlerunning{Sistemas Multiagentes en Realidad Virtual}

%\toctitle{Sistemas Multiagentes en Realidad Virtual}


\author{Gabriel L\'opez Garc\'ia \and Rafael Molina Carmona \and Antonio Javier Gallego S\'anchez}
\authorrunning{Gabriel L\'opez \and Rafael Molina \and Antonio Javier Gallego}

%\tocauthor{G. López \and R. Molina \and A. J. Gallego}


%\institute{Grupo de Inform\'atica Industrial e Inteligencia Artificial\\
%Universidad de Alicante, Ap.99, E-03080, Alicante, Spain\\
%\{glopez, rmolina, ajgallego\}@dccia.ua.es}





\maketitle


\begin{abstract}
..............

8 pages.

It should contain at least 70 and at most 150 words.

..............

%\keywords{We would like to encourage you to list your keywords within
%the abstract section}
\end{abstract}



%___________________________________________________________________________
\section{Introduction
\label{sec:introduction}}
%___________________________________________________________________________

The growing influence of Multi-Agent Systems (MAS) in several fields of research has led to a significant evolution in its development. Its application can be seen in a wide variety of disciplines such as sociology, economics, artificial intelligence, ecology, and so on. Some of the features that make these systems attractive include its power to simulate many types of situations, with different strategies and under different conditions. They also provide the richness needed to describe scenarios where the diversity and complexity are essential. Another important features is the ability of its components (agents) to communicate.

On the other hand, the spectacular progress of the Interactive Graphic Systems (IGS) has contributed to present the information in our environment in a more friendly way using new forms of analysis. Videogames and the entertainment industry in general, have had a decisive influence on this spectacular progress, developing excellent rendering and interaction systems, all at a reasonable cost. As a consequence, the way to visualize the information in videogames and in ISGs in general, has arrived to the field of research [Rhyne,2000].

The definition of an agent usually consists of a set of generic characteristics (autonomy, social skills, reactivity and proactivity [Gilbert,2008]) that make them difficult to model. Although there are some common strategies for implementing them, there is clearly a lack of a unified design pattern. As a consequence, some difficulties arise. One of these is the difficult reproduction of the results provided by the MASs, which supposes a tedious task of verification by several research teams [Axelrod,1997]. If the agents also include random characteristics to simulate strategies, the repetition of experiments becomes almost impossible [Gilbert,2008]. On the other hand, the visual representation of the MAS usually has a secondary character and is not sufficiently engaged, even if it is true that in recent years, there are some work environments that consider the visualization of the agents as an additional feature ([Luke et Al,2005], [North,2005], [Wilensky,1999]). Another problem associated with MAS refers to the possibility of changing the initial conditions of a given experiment in real time. This would enrich the results of the experiments and would be another interesting contribution provided by interactive systems. Therefore, the aid the IGSs can offer can be very interesting, both for the visualization of the MAS and for interactive testing.

In MASs, the connection of the agents with the environment has a vital importance. This relationship affects the activities of the agent, conditioning its behavior. For example, an agent can execute different actions if there is a risk of collision, if there is an attraction force (eg gravity) or if it must avoid an object. Within the IGS, the module responsible for managing the effects of environment on the objects in the scene is often called Physics Engine. The possibility of connecting the activities of agents with the effects of the Physics Engine would be very interesting, especially if the engine is implemented, as sometimes happens, on dedicated hardware.

On the other hand, IGSs are often part of more complex systems that attempt to model reality by incorporating, in addition to the aesthetic aspects, other aspects of behavior. A MASs could provide an intelligent behavior. That is the case, for example, of Virtual Reality systems in which the characters or avatars may have an agent-guided behavior.

The definition of a model that unifies the best of the MASs and the IGSs would be a major step in the evolution of these types of systems. This model would allow the specification of all the features necessary to define an agent, facilitating their visualization and interaction. It should also simplify the reproduction of experiments using a language to describe the scene and its elements, and facilitate the modification of the initial conditions. On the other hand, it could manage the relationship between Physics Engine and the agents, allowing the communication between the two systems. All this would require a common language for describing the scenes and their components.

This paper describes a proposal that incorporates features of the SMA and SG into a model based on grammars. The following section provides a description of the current situation of working environments for the development of SMA including some systems that use graphic resources to visualize the agents. In Section 3 the objectives to be achieved by the proposed model are defined. The proposed model is described in Section 4. Then, in Section 5, a case of study is proposed with the aim of showing the use of the whole system. Finally, some conclusions and possible lines of future work are presented.



%___________________________________________________________________________
\section{Background  /   Previous works
\label{sec:background}}
%___________________________________________________________________________

Nowadays there are many work environments to develop MASs. The main types are: specific environments using MAS-based solutions and work environments that define a generic architecture for the management of the main features of the MASs. However, with few exceptions, solutions to develop MASs where a IGS is an essential component are not proposed. The most common case is just implementing specific features of the MAS, such as the communication between agents, the parallel implementation of the MAS or the execution of different agents on different machines connected by a network.

One area where MASs are being incorporated with great success is Sociology ([Axelrod,1997],[Gilbert,2008], [Sawyer.2005], [Drogoul et Al., ]). In this case, very specific solutions are used, generally oriented to sociological studies. As examples, environments that simulate the movement of crowds can be referred [Ulicny et Al, 2001],[Olfati-Saber, 2004], or problems like the movement of groups of individuals stampeded out [Reynolds,2000]. In some cases, they use graphics to display statistics, or the density of agents within an environment. There are also systems such as the one described in [Reynolds,2000], where an animation of the movements of agents can be observed. Netlog [Wilensky,1999] is one of these environments, developed by Uri Winlesky in 1999 and it is being continually developed. To program the agents script language is used. It allows the implementation of everything that could be needed to define the behaviour. Netlog aims to study highly complex systems, exploring how the macro-behaviors emerge from the micro-behaviors specified for each agent through the script language. This system has developed some graphical features, but the agents are represented by Logo style triangles. This representation allows the user to observe the movement of each of the agents and the population density in different areas of the environment.

Some other applications of the MASs to Virtual Reality systems can be found. These systems usually consist of elements that make up a scene in which the user interaction is complex. One of these systems is described in [Maes et Al.1995] and it proposes an implementation of the virtual world where objects react to several gestures of a user. In the same line, in [Wachsmuth et Al, 1995] a system using the concepts of perception of the MASs applied to virtual reality is described. In this case, the agents react interactively with the user. As a final example, the work of [Gratch et Al, 2002] makes use of avatars to make the interaction with users more attractive. While not referring directly to agents, it uses very close concepts to those used in MASs as perception and reaction. These avatars react with different behavior to perceptions of the environment. All these examples use graphics systems. Nevertheless, there is no clear mechanism for linking the MAS and the IGS. Furthermore, they do not use generic models to implement MASs.

In the area of the entertainment industry, some MASs applied to games can also be found. In this case, the agents are usually called bots [Khoo et Al., 2002] and they are programmed as characters of the game, with objectives, strategies and actions. Everything is related to the environment around them. Programming is done with a specific script language for each game, so that characters cannot easily be transferred from one game to another, preserving their respective strategies. However, these systems are so successful that they are being used in research for some specific cases [Rhyne,2000]. 

So far, some specific applications of MAS models have been presented. Currently, however, an increasing variety of generic development environments with a similar philosophy are emerging: they implement the most important features of agents, ie, perception of the world, communication, reaction, etc.. [Gilbert,2008].

An example of a working environment for the development of MASs is Jade [Jade]. It has been developed in Java, it implements everything necessary to manage an MAS, it carries out operations of communication between agents and it models different types of activities. It can be run on several networked machines. However, it does not incorporate the possibility of using an IGS and the interaction with the agents is not considered, so interactive changes during the experiments are not possible. 

Repast [North et Al, 2005] is another environment to study simulations of groups of agents. It has an interface which is development for Java,. Net and Python. It is divided into several layers with a core from which to develop specific platforms like Repast S, used for social simulation. The system is based on models that define the behavior of agents. Its main components are the atom and the relationships between atoms. They are placed in a given space and then they can be drawn in 2D or 3D. It uses Eclipse as development environment.

Another environment in line with the previous one is MASON [Luke et Al., 2005]. Is developed in Java and it is defined as a simulation environment for discrete event-based MASs. It is designed for a wide type of applications, from social simulation to learning systems, as well as applications in robotics. The agents are divided into two layers. On the one hand, the layer of the model implements the execution of actions, the state updating and the environment management. On the other hand, if the agent is to be displayed, the display layer must be set. This layer is responsible for drawing the agent depending on its state. MASON ensures that experiments can be replicated regardless of the platform. It has a 2D and 3D visualization system for the agents, and it system can be run in a visual way in the course of time, creating animations.
 
As a conclusion, there are a variety of environments that implement the essential characteristics of the MASs and, in some cases, there are environments that use IGSs to display the agents. However, the system being proposed has as essential feature the implementation of an integrated formal model based on grammars, designed to merge the two areas in question: a MAS and a IGS. This implies that some aspects have been studied, in particular how it should be the communication of both types of systems, so that the systems designed with the formal model are readily available, transportable to different areas of application (simulation, videogames, social analysis). The use different types of visual devices as well as different types of interaction have carefully been considered too.



%___________________________________________________________________________
\section{Objectives
\label{sec:objectives}}
%___________________________________________________________________________

Los objetivos se orientan principalmente a conseguir un modelo que integre los SMA con SG mediante un lenguaje descriptivo y un sistema de eventos discretos. Se pretende que se pueda interactuar fácilmente para cambiar las condiciones iniciales, reproducir los experimentos tantas veces como se quiera y visualizar los componentes de la escena en tiempo real, independientemente del equipo donde se esté ejecutando. También se ha procurado que exista una independencia respecto de los dispositivos tanto visuales, como de interacción. Además, la importancia que tiene la definición del entorno para los SMA [Weyns et Al, 2007], hace necesaria la incorporación del motor físico, que ha sido ampliamente estudiado como parte de un SG pero no de un SMA. Esto es especialmente importante si se dispone de tarjetas hardware dedicadas para los cálculos necesarios en un motor físico, y que por tanto usarían los SMA.

Para todo esto sería necesario algún tipo de arquitectura que estructure de forma eficiente e integral todos los requerimientos antes especificados. Esta arquitectura deberá ser lo suficientemente flexible como para adaptarse a toda la diversidad que rodea tanto a los SMA, como a los SG. Para lograr esto se propone:


\begin{enumerate}
    \item Definir un motor gráfico que elimine la diversidad de los diferentes dispositivos visuales. Es decir, se desea que con una única descripción de la escena se procese de tal manera que se muestre en cualquier dispositivo gráfico y con un nivel de detalle acorde con sus características.

    \item Dotar al motor gráfico de la suficiente flexibilidad como para cambiar incluso la representación de los elementos y dar otro tipo de información, a petición del usuario, sin necesidad de modificar la descripción de la escena, enriqueciendo así el análisis de los datos arrojados por los SMA.

    \item Diseñar el motor gráfico de forma que no sea sólo específico para dispositivos visuales, sino que también se pueda utilizar para la extracción y uso de la geometría de los elementos que componen la escena, muy necesaria para que los agentes puedan saber cómo es el entorno que les rodea.

    \item Definir un motor físico que modele toda la actividad del sistema, adaptándose a los diferentes componentes hardware donde se va a ejecutar. Si se dispone de componentes hardware que implementan algoritmos físicos, el sistema debe aprovecharlos, pero si por el contrario no existen, los debe implementar mediante software.

    \item Diseñar el motor físico para que pueda, en cualquier momento, pedir al motor gráfico los datos que necesite y pueda realizar la función de simulación, así como el análisis, si fuera necesario, de los elementos que componen la escena. 

    \item Dotar al motor físico con la capacidad de poder transmitir la información procesada por él a los agentes para que estos puedan tomar decisiones acorde con sus deseos y considerando las limitaciones del entorno. Además podrá modificar los estados de los agentes si así lo requiere. Todo esto debe poder realizarse sin necesidad de saber con detalle la arquitectura de los elementos que componen la escena.

    \item Integrar el SMA con el motor físico considerando las limitaciones impuestas por éste. Esto supone que se debe realizar un trabajo importante en la integración de un sistema sobre el otro.

    \item Independizar la interacción respecto del sistema de hardware de entrada, de forma que se abstraiga del origen de la interacción y procese directamente las órdenes del usuario. Dicha interacción puede provenir, no sólo de dispositivos físicos, sino de procesos internos del sistema que producen interacción con la escena (por ejemplo, el cálculo de colisiones). De esta manera se podrían manipular agentes durante el proceso de experimentación de forma interactiva.

    \item Reutilizar los diferentes agentes de forma casi inmediata. Si, por ejemplo, se diseña un agente para un determinado escenario utilizando los mecanismos proporcionados por el sistema, se podrá reutilizar dicho agente en cualquier otra situación o aplicación que gestione un SMA.

    \item Abstraer los elementos diseñados del origen de la interactividad, de forma que se especifique a qué pueden reaccionar y en qué modo. Sin embargo, no sabrán necesariamente cuál es la causa del estímulo al que deben reaccionar.

    \item Toda la comunicación se ejercerá mediante eventos, pero siempre sin saber ni especificar cuál es origen del evento, dando importancia al evento en sí, y no a su procedencia. Esto también se refiere a la implementación de la comunicación entre agentes, punto muy importante en los SMA.
    
\end{enumerate}

Para el cumplimiento de todos estos objetivos se utilizarán modelos matemáticos que formalizarán los diferentes componentes, abstrayendo las características que definen los dos tipos de sistemas. Esta fuerte formalización ayudará a que se construyan fácilmente sistemas de generación automáticos o visuales que ayuden al desarrollo de los elementos que componen una escena de un SG.


%___________________________________________________________________________
\section{Model for Virtual Worlds Generation
\label{sec:model}}
%___________________________________________________________________________

Un escenario se caracteriza por un conjunto de elementos dinámicos o agentes, que pueden tener o no una descripción geométrica, y que realizan una actividad en un escenario compuesto por elementos estáticos que se visualizan. Esta visualización se va a definir mediante una secuencia ordenada de primitivas y transformaciones.

El concepto de primitiva se debe considerar, no sólo como una primitiva de dibujo usual (como el dibujo de una esfera, un cubo, etc.), sino más bien como una acción que se debe ejecutar en un determinado sistema geométrico que puede ser visual o no. Este sistema geométrico está representado por el conjunto G y cada primitiva es un elemento de dicho conjunto. Como ejemplo visual de una primitiva se puede pensar en el dibujo de una esfera en un motor gráfico, mientras que uno no visual puede ser la extracción de los límites de la esfera, necesario para obtener información del entorno que luego puede ser transmitido a un agente.

Una transformación es una modificación del comportamiento de las primitivas, la cual se aplica en el mismo sistema geométrico G. Al igual que la primitiva, se va a considerar la transformación no sólo como un escalado, un desplazamiento, un giro, etc., sino que va a definir también una asignación de color, la alteración de un sonido y todo aquello que represente una modificación del comportamiento de las primitivas dentro de G. Las transformaciones tienen un ámbito de aplicación y sólo se aplicará al conjunto de primitivas que se encuentren dentro de ese ámbito, extrayendo, al igual que las primitivas, información necesaria del entorno.

Por otro lado, se tiene como elemento dinámico el agente. Este está compuesto por un conjunto de actividades que representan su evolución a lo largo del tiempo, y un conjunto opcional que define los diferentes estados internos en los que puede hallarse, de los cuales sólo uno de ellos puede ser seleccionado. Dependiendo del estado seleccionado va a poder ejecutarse un conjunto particular de actividades. Toda actividad consiste en un proceso o función, denominada función de evolución, que se ejecuta como reacción a un determinado evento. Este puede ser producido por un dispositivo de entrada o por otra actividad, tanto del mismo agente como de otro. Por tanto, una actividad se compone tanto del proceso de ejecución como del evento o conjunto de eventos que la han activado. Como ejemplos de actividad se tiene la modificación del estado interno del agente (posibilitando que se ejecuten otras actividades), la eliminación de los agentes que se sitúan a su alrededor, o el movimiento del agente en el escenario dado.

El concepto de evento dentro de un agente es importante, ya que define cuándo se va a ejecutar la actividad además de definir unos datos asociados necesarios para la actividad. Por ejemplo, un evento de movimiento puede generarse cuando se mueve un ratón con los datos del movimiento. La generación del evento va a ser independiente del dispositivo de entrada. Es decir, se separara el dispositivo de la actividad que se debe procesar. Por ejemplo, el evento de movimiento se puede generar también al pulsar el teclado o como resultado de una decisión tomada por un agente. Además, los eventos van a ser la vía por el cual se va a definir las diferentes formas de comunicación que puede existir en un SMA (comunicación entre agente-agente y entre agente-entorno).

No toda actividad tiene porqué ejecutarse siempre cuando se envía un evento. Pueden existir determinados eventos que ejecuten la actividad sólo si se cumplen ciertas condiciones, entre ellas el estado interno del agente.
	
\begin{table}[h]
\begin{center}
\begin{tabular}{|l|}
    \hline

    Rule 1.- \textbf{WORLD} $\rightarrow$ OBJECTS \\

    Rule 2.- \textbf{OBJECTS} $\rightarrow$ OBJECT $|$ OBJECT · OBJECTS \\

    Rule 3.- \textbf{OBJECT} $\rightarrow$ FIGURE $|$ TRANSFORMATION $|$ AGENT \\

    Rule 4.- \textbf{AGENT} $\rightarrow$ $a^d_s$ (OBJECTS), $a^d_s \in \textbf{A}^D_S, d \in D, s \in S$ \\

    Rule 5.- \textbf{TRANSFORMATION} $\rightarrow t$ (OBJECTS), $t \in T$ \\

    Rule 6.- \textbf{FIGURE} $\rightarrow$ $p^+$, $p \in P$ \\

    \hline
\end{tabular}
\end{center}
\label{tab:rules}
\caption{Grammar rules $R^*$}
\end{table}
	
	
A string $w \in \Sigma^*$ is generated by the grammar $M$ if it can be
obtained starting with the initial symbol WORLD and using the rules of the
grammar. The language generated by the grammar $M$ is the set of all the strings
which can be generated by this method. This language is called $L(M)$ and is
defined as:

\begin{equation}
 L(M) = \lbrace w \in \Sigma^* \ | \ \text{WORLD} \stackrel{*}{\rightarrow} w \rbrace
\end{equation}


The grammar $M$ is a context-independent grammar (or a type-2 grammar, according to the Chomsky
hierarchy). Therefore, there is a procedure which verifies if a scene is correctly described or, in
other words, if a string belongs to the language $L(M)$ or not. For example, it can be determined
that the string $a_1^d ( p_1 \cdot p_2) \cdot p_3 \cdot t_1 ( p_1 \cdot p_2 ) \in L(M)$ where $p_i
\in P$, $t_i \in T$, $a_i^d \in A^D_S$, but, on the contrary, $a_1^d \cdot p_1 \notin L(M)$.

Apart from the language syntax, it is necessary to define the functionality of the strings, that is,
the semantics of the language. It can be denoted through three methods: operational, denotational and axiomatic. In our case, the denotational method is used. It The defines the meaning of the string through mathematical logic terms.


%___________________________________________________________________________
\subsection{Semantics of the Language $L(M)$
\label{sec:semantic}}

In this section, a mathematical function is assigned to each rule of Table 1.


%___________________________________________________________________________
\subsubsection{Semantic Function for Primitives (Rule 6)
\label{sec:rule6}}

Rule 6 defines the syntax of a figure as a sequence of primitives. Primitive's semantics is defined
as a function $\alpha$. Each symbol in the set $P$ carries out a primitive on a given geometric
system $G$. Therefore, the function $\alpha$ is an application defined as:	
	
\begin{equation}
    \alpha: P \rightarrow G
\end{equation}
	
So, depending on the definition of the function $\alpha$ and on the geometric system $G$, the result of the system may be different. $G$ represents the actions which are run on a specific geometric system. A usual example of geometric system are graphical libraries, such as OpenGL or Direct3D. In this
case, each symbol of $P$ would have associated an action of the render system. For instance, given
the symbol of a sphere ($sphere \in P$), it would implement a function which draws this object in
the corresponding graphics system (Direct3D or OpenGL):	
	
\[ \begin{matrix}
    \alpha_{opengl}(sphere) = glutSolidSphere \\
    \alpha_{direc3d}(sphere) = drawSphereDirect3D
\end{matrix} \]

These functions are examples of visual geometric systems. But this definition can also be extended
to non-visual geometric systems. For example, a non-visual system could be the calculation of the
boundaries of a figure, which could be used to calculate collisions between elements. So, a new
function $\alpha_{bounds}(sphere) = boundSphere$ can be defined for the same alphabet $P$, where
``\textit{boundSphere}'' is a function which calculates the limits of spheres.
	
Previous examples show that the function $\alpha$ provides the abstraction needed to homogenize the different implementations of a render system. Therefore, only a descriptive string is needed to run the same scene on different graphics systems. ************ Esto sobre todo es importante para relacionar los agentes con el motor físico. Los procesos de extracción de la información del entorno se ejecutan en módulos geométricos y componen el motor físico de un SG. La información procesada es enviada a los agentes lo suficientemente tratada como para que estos puedan realizar su actividad usando solo los elementos del motor físico.
	
So far, only Euclidean geometric systems have been considered. But, the function $\alpha$ has no
restrictions on the geometric system that can be applied as long as there is a definition for this
primitive. Thus, it could also implement a sound, the movement of a robot, the reflection of a
material and so on. Moreover, the definition of the function $\alpha$ could also describe systems
to send strings in a network, which is very important in a MAS.
	
	
%___________________________________________________________________________
\subsubsection{Semantic Function for Transformations (Rule 5)
\label{sec:rule5}}
	
Rule 5 defines the syntax for transformations. The scope of a transformation is
limited by the symbols ``()''. Two functions are used to describe the semantics
of a transformation. These functions are:

\begin{center}
\begin{tabular}{l}
    $\beta: T \rightarrow G$ \\
    $\delta: T \rightarrow G$
\end{tabular}
\end{center}

$\beta$ represents the beginning of the transformation. It is carried out when the symbol ``('' is
processed and it has to take into account the previous symbol of the set $T$. The function $\delta$
defines the end of the transformation which has previously been activated by the function $\beta$.
It is carried out when the symbol ``)'' is found.

These two functions have the same features that the function $\alpha$, but they
are applied to the set of transformations $T$, using the same geometric system
$G$.

A new function $\varphi$ is defined using the set of primitives $P$, the set
of transformations $T$ and the functions $\alpha$, $\beta$ and $\delta$. Given a
string $w \in L(M)$ and using only symbols of $P$ and $T$, this function
$\varphi$ runs the sequence of primitives and transformations in the geometric
system $G$. It is defined as:

\begin{equation}
    \varphi (w) = \left\{
    \begin{array}{ll}
        \alpha(w) & \mathit{if} \ \ w \in P  \\

        \beta(t); \varphi(v); \delta(t) & \mathit{if} \ \ w = t(v)
\wedge v \in L(M) \\

        \varphi(s); \varphi(t)  & \mathit{if} \ \ w = s \cdotp t \wedge
s, t \in L(M)
    \end{array}\right\}
\end{equation}


One of the most important features of this system is the independence on specific graphics
system. The definition of the functions $\alpha$, $\beta$ and $\delta$ provides the differences in
behaviour. These functions encapsulate the implementation details which may differ for different
systems, such as a render system, a geometric calculation system, a command execution system in a
production chain, and so on. Therefore, in the development of strings to define virtual worlds is
not necessary to consider the special features of the geometric system. In addition, these strings 
may be used on all the systems which implement these functions.

	

%___________________________________________________________________________
\subsubsection{Semantic Function for Agents (Rule 4)
\label{sec:rule4}}

Rule 4 of the grammar $M$ refers to agents, which are the dynamic part of the system and the elements that compose a MAS. The semantics of agents is a function which defines its evolution in time. For this reason, the semantic function is called \textit{evolution function} $\lambda$ and it is defined as:

\begin{equation}
    \lambda: L(M) \times E^D \rightarrow L(M)
\end{equation}

where $E^D$ is the set of events for the device $D$ ****************(considerando estos dispositivos como cualquier proceso software o hardware que emite eventos) and the strings $w \in L(M)$ fulfill the
syntactic rule 4. The function $\lambda$ can be interpreted as the evolution of the agent in time, ****************** ya que si w representa un agente, al aplicar la función λ(w,ef), w se transforma en otra cadena u, lo que nos permite hacer evolucionar el sistema. $\lambda$ has a different expression depending on its evolution. However, the general expression can be defined as:

\begin{equation}
    \lambda (a^{d}(v),e^{f})=
    \left\{
    \begin{array}{ll}
        u \in L(M) & \mathit{if}  \ \ f = d \\
        a^{d}(v)  & \mathit{if}  \ \ f \neq d
    \end{array}\right\}
\end{equation}


The result of the function $\lambda$ may contain or not the own agent, it can generate other
event for the next stage (or the next frame) or change the state 's' of the agent. So, an agent can become a generator of events. The new events generated by agents are accumulated to be passed to the next stage of the system
evolution. In this way, the communication between agents can be modeled, as well as the communication between agents and environment, so important in a MAS. In the case that the event does not match with the triggering event, then this function returns the same agent, and the string remains unchanged. 

The function $\lambda$ can define a recursive algorithm which, given a set of
events and a string, describes the evolution of the system at a given point
in time. This function is called \textit{function of the system evolution} and
it is represented by $\eta$. Its definition requires a set of events
$e^i, e^j, e^k, \dots, e^n$, which in short is denoted as $e^v$, where $v
\in D^+$. This algorithm is defined as:

\begin{equation}
    \eta (w, e^v) = \left\{
    \begin{array}{ll}
        w   & \mathit{if}  \ \ w \in P  \\

        t(\eta (v, e^v))    & \mathit{if}  \ \  w = t(v)  \\

        \underset{\forall f \in v}{ \prod }(\lambda (a^d (\eta
            (y, e^v)), e^f))    & \mathit{if}  \ \ w = a^d(y)
\\

        \eta (s, e^v) \cdot \eta (t, e^v)   & \mathit{if}  \
\  w = s \cdot t
    \end{array}\right\}
\end{equation}

The operator $\underset{\forall f \in v}{ \prod }(\lambda (a^d (\eta (y, e^v)), e^f))$ concatenates
the strings generated by the function $\lambda$. It is important to note that the strings which are
only composed of transformations and primitives are not processed. Therefore, these strings are not
part of the system evolution, so they are only part of the environment that can be analyzed by agents.
	
The functions $\lambda$ can be classified in accordance with the strings which are obtained during
the evolution of the system. One important type of $\lambda$ functions are those which return
strings with only primitives and transformations, because they are essential to define the
visualization of strings. As it was explained before, the functions $\alpha$, $\beta$ and $\delta$ do
not admit strings with agents. Therefore, agents must be first converted into strings made up only
of primitives and transformations. This conversion is carried out by a type of function $\lambda$
called \textit{visualization function}, or function $\theta$, which is defined as:


\begin{equation}
    \theta: L(M) \times E^V \rightarrow L(E)
\end{equation}


where $V \subseteq D$, $E^V$ are events created in the visualization process, and $L(E)$
is the language $L(M)$ without agents. The expression of the visualization function is defined as:


\begin{equation}
    \theta (a^d(v), e^f) =
    \left\{
    \begin{array}{ll}
        u \in L(E) & \mathit{if}  \ \ f = d \wedge d \in V \\
        \epsilon  & \mathit{if}  \ \ f \neq d
    \end{array}\right\}
\end{equation}

There are small differences between $\lambda$ and $\theta$. The first one is that $\theta$ returns
strings belonging to $L(E)$. The second is that $\theta$ returns an empty string if the event does
not match. So, the agent will not have representation for that event.

The type of event $V$ (visualization event) does not correspond to any specific input device. It is used 
to create different views of the system. *********************** Este analiza la actual situación del sistema para poder enviar esta información a los agentes, estableciendo así una relación entre los agentes y el motor físico. For example, to design a system which filters out certain elements in order that they become invisible, it is only necessary to avoid reacting to those events. Moreover, they can also be used to change the visualization type, depending on the type of window, or on the output device and its features, or they can move a mobile robot through primitives of movement.

As with the function $\lambda$, an algorithm is defined for $\theta$. It returns a string $z \in
L(E)$, given a string $w \in L(M)$ and a set of events $e^v$, where $v \in V^+$ and $V \subseteq
D$. This function is called \textit{function of system visualization} $\pi$ and it is defined as:


\begin{equation}
   \begin{array}{c}
    \pi: L(M) \times E^V \rightarrow L(E) \\
\\
    \pi (w, e^v) = \left\{
    \begin{array}{ll}
        w   & \mathit{if}  \ \ w \in P^+  \\

        t(\pi (y, e^v))     & \mathit{if}  \ \  w = t(y)  \\

        \underset{\forall f \in v}{ \prod }(\theta (a^v (\pi
            (y, e^v)), e^f))    & \mathit{if}  \ \ w = a^v(y)
\\

        \pi (s, e^v) \cdot \pi (t, e^v)    & \mathit{if}  \
\  w = s \cdot t
    \end{array}\right\} \\
   \end{array}
\end{equation}



%___________________________________________________________________________
\subsubsection{Semantic Functions for OBJECT, OBJECTS and WORLD (Rules 1,
2 and 3)
\label{sec:rules123}}
	
The semantic function of these rules breaks down strings and converts them into substrings. The
functions specified above are carried out depending on whether the symbol is an agent, a
transformation or a primitive. Therefore, the semantic function of WORLD is a recursive function
which breaks down the string of the WORLD and converts it into substrings of OBJECTS. Then, these
substrings are in turn broken down into substrings of OBJECT. And for each substring of OBJECT,
depending on the type of the object, the semantic function of AGENT, PRIMITIVE or TRANSFORMATION is
run. ***************** Se debe observar que las primitivas que no son generadas por los agentes con la función de visualización representan la parte estática del sistema, o lo que es lo mismo, el entorno geométrico donde se desarrolla la actividad del sistema.



%___________________________________________________________________________
\subsection{Activity and Events
\label{sec:activity_events}}
	
In MAS some mechanisms must be established to model the activity of the system.
This activity can appear during the action of an agent, between several agents with a certain
relationship (for example, an agent which is composed of other agent -which are their children-
and there is some activity between them), and between input devices and scene's strings. Each type
of activity is different, but they have some features in common, and they are going to be
established.
	
As it has been said before, agents activity is carried out when a certain type of event is produced
with some specific data. But not all activities are directly run when an event is received. There
are events that only run its activity when certain conditions are satisfied, depending on the
agent state. This condition is not defined at the object that runs the activity, but at the event.
The following event definition is established:

{\itshape
$e_c^d$ is defined as an event of type $d \in D$ with data $e$, which is carried out only when the
condition $c$ is fulfilled. When there is not any condition, that is, $c = TRUE$, the event is
represented by $e^d$.
}
	
Let us notice that the origin of events is not identified. In fact, the origin is not
important, but the event type and its data. ******************* Esto no quiere decir que en el evento no se puedan incluir datos que identifiquen a quién envía el mensaje. Por ejemplo, en la comunicación entre dos agentes  los eventos pueden contener información sobre quién envió el mensaje y qué tipo de dato se envía. De esta manera se establece un sistema genérico de comunicación que puede implementar KMQL o FIPA [Genesereth et Al., 1995] o incluso los dos a la vez implementando varios dialectos.
	
	
	
	
%___________________________________________________________________________
\subsection{Input Devices and Event Generators
\label{sec:input_devices}}
	
It is necessary to establish the independence between the system and the input devices (hardware or software), 
considering these input devices such as any process capable of generate events. So, the events needed to make 
the system respond to a set of input devices must be defined. It means that
there may be actions on input devices (buttons, mouse wheel, movements and so on) which generate
one or more events, and others which do not generate any. The input devices need not be only 
physical devices, they may be software devices which, depending on their performance, may or may not
generate events and send the processed information to the agents that compose the scene. 	
It allows to establish a mechanism to provide environment information to agents.
For example, a mouse could be used as input device to move a character in a game. However, there has 
not to be a mouse event associated to the character; instead the mouse has an event generator which
creates generic events of movement which are associated to the character.
*********************** De esta manera se puede generar eventos de movimiento del personaje no sólo con el ratón sino con cualquier proceso software que sea necesario siempre y cuando genere el mismo tipo de evento.
On the other hand, an example of software device may be an algorithm
for detecting collisions. In this case, an event can be generated when a collision is detected 	
and send that information to agents who are involved in the collision to establish their reactions.	
	
A new function called \textit{event generator} is defined as:

{\itshape 
Let $C^d(t)$ be a function which creates events of type $d$ at the time instant $t$,
where $d \in D$ and $D$ is the set of event types which can be generated by the system. }	
	

In the previous definition, it should be noticed that events are generated in the time instant $t$.
It is due to synchronization purpose. It is also possible that $C$ does not create any event at a
given moment. The most interesting fact about the implementation of the event generator
is that the device-dependent code is encapsulated and separated from the rest.

One problem is that different event generators can create the same type of events. So, a priority
order among event generators must be established to avoid ambiguities. Given two generators $C_i$
and $C_j$ which create the same event, if $i < j$, then the events generated by $C_i$ will have a
higher priority.

The process which obtains the events produced by input devices and their associated 
generators is defined as follows:



{\itshape

Let $C^*$ be the set of all the event generators which are associated with input
devices.

}


The function $e(z, e^i)$ which concatenates all the events in a list is defined
as:

\begin{equation}
    e(z, e^i) = \left\{
    \begin{array}{ll}
        z \cdot e^i   &   \mathit{if} \ \ e^i \notin z \\
        z    &   \mathit{if} \ \ e^i \in z
    \end{array}
    \right\}
\end{equation}


The function $E(C^*, t)$ collects all the events from all the generators and accumulates them in a
list. If the event $e^i$ already exists, then it is not inserted in the list. This function is
defined as:


\begin{equation}
    E(C^*, t) = \left\{
    \begin{array}{ll}
        e(z, C_i(t))   &  \mathit{if}  \ \ z = E(C^* - C_i, t) \\
        \epsilon   &  \mathit{if} \ \ C^* = \emptyset
    \end{array}
    \right\}
\end{equation}


Tanto con los generadores de eventos como con los eventos que genera los agentes, se puede modelar todo lo relacionado con los procesos de comunicación que existen en los SMA. Para comunicar dos agentes sólo se debe establecer en la función de evolución los casos en los que el agente genera un evento. Este evento se envía al siguiente frame dando la posibilidad de que pueda ser recogido por uno o varios agentes. Así, el agente que originó el evento puede pasar información a otros agentes y estos a su vez, con el mismo mecanismo, pueden transmitir más información al agente origen.

Por otra parte, mediante los generadores de eventos se puede implementar la comunicación necesaria entre los agentes y el entorno: simplemente hay que definir un generador de eventos para cada aspecto que se quiera considerar como información del entorno y que debe ser transmitida al agente. Por ejemplo, si se define un motor físico que va a calcular la gravedad que influye sobre determinados agentes (aquellos que están en el campo gravitatorio), a este motor se le va a definir un generador de eventos que bajo determinadas condiciones va a crear un evento cuya información contendrá todo lo necesario para que los agentes puedan establecer cual va a ser su reacción ante esta fuerza de gravedad.



%___________________________________________________________________________
\subsection{System Algorithm
\label{sec:system_algorithm}}


Once all the elements involved in the model to manage a MAS have been defined, the algorithm which carries out the
entire system can be established. It defines the system evolution and its visualization at every
time instant `$t$' or frame. The \textit{Algorithm of Virtual Worlds Generation} is defined as:

		
\begin{center}
\begin{tabular}{|ll|}
    \hline

    Step 1. & $w = w_o$ \\

    Step 2. & $t = 0$ \\

    Step 3. & $e^* = E(G^*, t)$ \\

    Step 4. & $e^v =$ events of $e^*$ where $v \in V^+$ \\

    Step 5. & $e^u = e^* - e^v$ \\

    Step 6. & $w_{next} = \eta(w, e^u)$ \\

    Step 7. & $v =  \pi(w, e^v)$ \\

    Step 8. & $g = \varphi(v)$ \\

    Step 9. & $w = w_{next}; \ \ t = t + 1$ \\

    Step 10. & If $w = \epsilon$ then go to step 12 \\

    Step 11. & Go to step 3 \\

    Step 12. & End \\

    \hline
\end{tabular}
\end{center}


Where:


\begin{itemize}
    \item $D$ = \{ Set of all the types of possible events in the system \}.

    \item $V$ = \{ Set of all the types of visual events \} where $V \subseteq D$.

    \item $G^*$ = \{ All the event generators which generate events of type $D$ \}.

    \item $g$ is the output device.

    \item $e^*$ are all the events generated by the system in a frame $t$.

    \item $e^v$ are all the events from visual devices. These events are one of 
the inputs of the visual algorithm $\pi$.

    \item $e^u$ are all the events from non-visual devices. These events
are the input of the evolution algorithm $\eta$.

    \item $w_o$ is the intial string of the system.
\end{itemize}
	


The first two steps initialize the system. The initial state $w_o$ is
introduced to the system and the first frame is set to 0.

Steps 3, 4 and 5 manage the system events. In Step 3, generators are called to insert all the
events in a list $e^*$. In Steps 4 and 5, events are divided into visual events ($e^v$, which are
the input of the visual algorithm $\pi$) and non-visual events ($e^u$, which are the input of the
evolution algorithm $\eta$).

In Step 6, the evolution algorithm $\eta$ is called with the current string $w$ and the non-visual
events ($e^u$). The output is the string for the next frame or instant $t$.

In Step 7 and 8, the visualization of the system is performed. First, agents are transformed into
primitive and transformations. Next, the visualization algorithm $\pi$ is called with the visual
events ($e^v$). Finally, the function $\varphi$ is called to display the current state of the
system into the render engine $g$.
	
In Step 9, the next iteration is prepared. $w$ is assigned to $w_{next}$ and the time instant (or
current frame) is increased in 1.

Step 10 checks if the current string satisfies the condition of completion, that is, if the
following string is empty, then the algorithm ends (Step 12). Otherwise, the algorithm goes to Step
3. Therefore, to finish the main algorithm the function $\alpha$ must just return an empty string.
This empty string can be generated by a special event which is created when the system must stop.

It must be noticed that Step 6 can be exchanged with Steps 7 and 8, because they do not share any
data. This feature is very important for the parallel implementation of the algorithm. So, Step 6
and Steps 7 and 8 can be divided into two parallel tasks. This type of optimization has a
significant impact on the final graphics system, which leads to a faster system performance.
	
This formalization of the system has two main consequences. First, the scene definition is
separated from the hardware-dependent characteristics of components. The functions $\alpha$,
$\beta$ and $\delta$ provide the independence from the visualization system, and the event
generators provide the independence from the hardware input devices. Secondly, due to the fact that
there is a specific scheme to define the features of a system, the different system elements can be
reused easily in other areas of application.
	
	
	
%___________________________________________________________________________
\section{Case of Study
\label{sec:case_study}}
%___________________________________________________________________________

This section describes a case of study which shows the steps to define a system using the proposed
model. This example is an application that simulates fires in forests caused by lightning. It could
be used to analize the best distribution of trees to reduce the number of burnt trees
\cite{John2007}.

El sistema, básicamente, consiste en un agente que define lo que se denomina el bosque, el cual genera agentes que implementan árboles y relámpagos. En primer lugar se realiza una descripción detallada del problema que se desea resolver mediante SMA, para luego definir todos los componentes con el modelo formal especificado.


%___________________________________________________________________________
\subsection{Problem description
\label{sec:description_problem}}
%___________________________________________________________________________

*********** El problema consiste en la representación de un mundo, donde cada cierto tiempo crece un árbol con una cierta probabilidad g. El crecimiento de un árbol hace que este se sitúe en un determinado lugar (i,j) de un tablero 2D. 
***********
Bolts of lightning can also fall on a $(i, j)$ position
with a probability $f$. In this case, if there is a tree, it will burn as well as
the trees around it, in a chain reaction.

To model this example with the proposed model, four main elements need to be defined.
First, it is necessary to define events for the system to run agent activities. These events
include the necessary information to develop their activity. Second, it is necessary to design
event generators that separate the interactive system from the origin of the events (mouse, keyboard, and
so on). Third, it is necessary to define the agents included in the scene. These elements are
required for the system to evolve over time. Last, the graphic primitives must be defined to show 
the visual elements on the render system.
	


%___________________________________________________________________________
\subsection{Formalization of the system
\label{sec:formalization_system_model}}
%___________________________________________________________________________

Following the steps described above, the different elements of the system are defined.

Events are used to produce the necessary activity of system. They are described by an
identifier and a set of data. Their aim is to produce certain activities of the agents that
compose the scene. The events defined for this example are shown in table \ref{table1}.

\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|p{0.1\linewidth}|p{0.35\linewidth}|p{0.35\linewidth}|}

    \hline
    \itshape Type of event &
    \itshape Meaning &
    \itshape Associated data\\

    \hline
    $t$ &
    Event generated every time instant $t$
    &
    Increasing time since previous event\\

    \hline
    $c$ &
    Create a tree at a given position &
    Position (i,j) where the tree is created \\

    \hline
    $f$ &
    Create a bolt of lightning at a given position &
    Position (i,j) where the bolt of lightning is created\\

    \hline
    $e$ &
    Eliminate the tree at a given position &
    Position (i,j) where the tree is eliminated\\

    \hline
    $b$ &
    Burn the tree at a given position &
    Position (i,j) where the tree to be burned is\\

    \hline
    $v$ &
    Draw using a graphics library (e.g. OpenGL) &
    Void\\

    \hline

\end{tabular}
\end{small}
\caption{\label{table1} Events definition}
\end{center}
\end{table}


The next step is to define the event generators:

\begin{enumerate}

\item Time event generator: 
This generator, named by $C_{time}$, has the responsibility of animating the system. Every time
instant $t$, it generates an event $e^t$ that is usually associated with some type of primitive
transformation to change the appearance of an agent over time.

\item Forest event generator:
This generator produces events to create trees and lightning. Taking into account the
previous specification, trees are created with a probability $g$ and lightning with a probability
$f$. This generator is defined as:

\[C_{forest}=
    \left\{
        \begin{matrix}
            e^{c} & with \ probability \ g \\
            e^{f} & with \ probability \ f
        \end{matrix}\right\}\\
\]

\item Visualization event generator:
This generator is necessary to visualize all the elements in the scene. This means that every
instant time a drawing order is received, the generator captures this order and produces an 
event, sending the draw elements of the scene to the graphics system. Its mathematical expression
is given as:

\[C_{visualization} = \{ e^o \ \mathit{each \ drawing \ cycle} \} \]
\end{enumerate}


The primitives and transformations that make up the scene are shown in tables \ref{table2} and
\ref{table3}:

\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|l|l|}

	\hline \itshape Primitive & \itshape Description\\
	\hline TR & Draw a tree\\
	\hline TRB & Draw a burning tree\\
	\hline FA & Draw a bolt of lightning\\
	\hline BO & Draw a grid of NxN \\
	\hline

\end{tabular}
\end{small}
\caption{ \label{table2} Definition of primitives}
\end{center}
\end{table}


\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|l|l|}

	\hline \itshape Transformations & \itshape Description\\
	\hline $D_{i,j}$ & Translate (i,j)\\
	\hline $S_{s}$ & Scale (s)\\
	\hline

\end{tabular}
\end{small}
\caption{\label{table3} Definition of transformations}
\end{center}
\end{table}


The functions ${\alpha}$, ${\beta}$ and ${\delta}$ define these primitives and transformations 
and they are implemented with a graphics library (in this case OpenGL). This way, the number of 
primitives and transformations can be easily extended just implementing them in the functions 
${\alpha}$, ${\beta}$ and ${\delta}$.


The last step is to specify the agents which compose the dynamic part of the system. As explained in previous sections, an agent is defined by its evolution function $\lambda$. If it has a graphical representation, it also uses the function $\pi$ to generate the primitives and the transformations needed to create that representation. Table \ref{table4} shows the agents defined for this example and their evolution function.

\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|p{0.05\linewidth}|p{0.17\linewidth}|p{0.6\linewidth}|}
%{|l|l|l|}
%{|p{1cm}|p{2.6cm}|p{2.6cm}|}

	\hline 
	\itshape Agent & \itshape Description & \itshape Function ${\lambda}$\\
	\hline

	$B^{cfe}$ & Represents the forest &
	$\lambda
	(B^{\mathit{cfe}},e^{i})=\left\{\begin{matrix}\mathit{TG}^{t}\cdot
	B^{\mathit{cfv}}\hfill\null &i=c\hfill\null \\F^{t}\cdot
	B^{\mathit{cfv}}\hfill\null &i=f\hfill\null
	\\B^{\mathit{cfe}}\hfill\null &i=e\hfill\null
	\\B^{\mathit{cfe}}\hfill\null &f\neq c,r,v\hfill\null
	\end{matrix}\right\}$ \\

	\hline

	$TG^{t}$ & Represents the growth of a tree &
	$\lambda
	(\mathit{TG}^{t},e^{i})=\left\{\begin{matrix}\mathit{TG}^{t+1}\hfill\null
	&i=t\wedge t+1\leqslant N_{\mathit{frames}}\hfill\null
	\\T^{b}\hfill\null &i=t\wedge t+1>N_{\mathit{frames}}\hfill\null
	\\\mathit{TG}^{t}\hfill\null &i\neq t\hfill\null \end{matrix}\right\}$ \\

	\hline

	$T^{b}$ & Represents a tree &
	$\lambda (T^{b},e^{i})=\left\{\begin{matrix}\mathit{TB}^{t}\hfill\null
	&i=b\hfill\null \\T^{b}\hfill\null &i\neq b\hfill\null
	\end{matrix}\right\}$ \\

	\hline

	$F^{t}$ & Represents the animation of a bolt of lightning  &
	$\lambda (F^{t},e^{i})=\left\{\begin{matrix}F^{t+1}\hfill\null
	&i=t\wedge t+1\leqslant N\hfill\null \\\Delta e^{b}\hfill\null
	&i=t\wedge t+1>N_{\mathit{frames}}\hfill\null \\F^{t}\hfill\null &i\neq
	t\hfill\null \end{matrix}\right\}$ \\

	\hline

	$TB^{t}$ & Represents a burning tree &
	$\lambda
	(\mathit{TB}^{t},e^{i})=\left\{\begin{matrix}\mathit{TB}^{t+1}\hfill\null
	&i=t\hfill\null \\\Delta e^{e}\hfill\null &i=t\wedge
	t+1>N_{\mathit{frames}}\hfill\null \\\mathit{TB}^{t}\hfill\null &i\neq
	t\hfill\null \end{matrix}\right\}$ \\
	\hline

\end{tabular}
\end{small}
\caption{\label{table4} Agents defined for this example}
\end{center}
\end{table}



Agent $B^{cfe}$ represents the forest. This agent generates a tree or a bolt of lightning, if it receives the event $e^{c}$, the event $e^{f}$ respectively. The agents generated by these events are introduced in the string at next fame. These agents are $TG^{t}$ and $F^{t}$. The event $e^{e}$ only changes the internal state of the agent $B^{cfe}$. It frees its position ($i, j$), so a new tree may grow in the same position.

Por otro lado, está el agente que define un árbol. Tiene tres estados internos S = {c, a, i}. El estado 'c' corresponde al estado de crecimiento del árbol, el estado 'a' corresponde al árbol ya crecido o en estado adulto y el estado 'i' es el estado del árbol incendiándose. Este agente reacciona a los eventos et que se utilizan para hacer las animaciones y eq que cambian el estado del árbol a incendiado. De la función de evolución de este agente se puede destacar la transición entre estados que tiene el agente dependiendo del evento. Por ejemplo, cuando se termina la animación del árbol creciendo (segunda linea de la función) se puede observar como el agente pasa del estado 'c' al estado 'a'. Otro caso de cambio de estado es cuando el agente recibe un evento eq y pasa del estado 'a' al estado 'i'. Además de cambiar de estado, se ejecuta una función Vecinos que lanza a cada árbol vecino un evento de quemado eq.

$F^{t}$ is similar to $TG^{t}$, unless it creates a bolt of lightning. When the animation ends, it generates an event $e^{b}$ that burns the tree.

Tanto la llamada de un árbol a Vecinos para enviar a un evento eq a cada uno de sus vecinos, como cuando un relámpago termina su animación y manda el evento eq al árbol donde está el relámpago, son dos ejemplos de comunicación entre agentes. En el caso de que un relámpago mande un evento eq a una posición en la que no hay ningún árbol, este evento no procesará ninguna actividad. Otro tipo de comunicación es el que se establece entre el bosque y el generador Cbosque para modificar el entorno, en este caso el bosque crea árboles o relámpagos.

Table \ref{table5} shows the definition of the drawing function $\pi$. This function is used to obtain the set of primitives and transformations representing the visual aspect of an agent, which is shown on the display.


\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|l|l|}

    \hline \itshape Agent & \itshape Function ${\pi}$ \\
    \hline
    $B^{v}$ &
    $\pi (B^{v},e^{i})=\left\{\begin{matrix}\mathit{BO}\hfill\null
        &i=v\hfill\null \\\epsilon \hfill\null &i\neq v\hfill\null
        \end{matrix}\right\}$   \\

    \hline
    $TG^{v}$ &
    $\pi (\mathit{TG}^{v},e^{i})=\left\{\begin{matrix}D_{(i,j)}(S_{s}(\mathit{TR}))\hfill\null
        &i=v\hfill\null \\\epsilon \hfill\null &i\neq v\hfill\null
        \end{matrix}\right\}$   \\

    \hline
    $T^{v}$ &
    $\pi(T^{d},e^{i})=\left\{\begin{matrix}D_{(i,j)}(\mathit{TR})\hfill\null
        &i=v\hfill\null \\\epsilon \hfill\null &i\neq v\hfill\null
        \end{matrix}\right\}$   \\

    \hline
    $F^{v}$ &
    $\pi(F^{d},e^{i})=\left\{\begin{matrix}D_{(i,j)}(\mathit{FA})\hfill\null
        &i=v\hfill\null \\\epsilon \hfill\null &i\neq v\hfill\null
        \end{matrix}\right\}$   \\

    \hline
    $TB^{v}$ &
    $\pi(\mathit{TB}^{v},e^{i})=\left\{\begin{matrix}D_{(i,j)}(S_{s^{-1}}(\mathit{TRB}))\hfill\null
        &i=v\hfill\null \\\epsilon \hfill\null &i\neq v\hfill\null
        \end{matrix}\right\}$   \\

    \hline
\end{tabular}
\end{small}
\caption{\label{table5} Definition of the drawing function}
\end{center}
\end{table}



$S$ represents a growing scale factor which depends on the current state of the agent $TG$. This state is modified by the event $e^{t}$. It causes the effect of tree's growth. The scale value is defined by the expression $s = t / N$, where $N$ is the total number of frames and $t$ is the current instant of time. However, in the case of $TB$ the scale factor is defined as a decreasing scale $s^{-1}$. It causes the effect of a burning tree, which is getting smaller. 	
This is an example of how an agent can have different representation depending on its internal state.

The animation of a bolt of lightning is implemented by an algorithm which depends on the instant of time $t$. In general, agents' animations always depend on $t$. It modifies the current state of the agent to change its representation and thus perform the animation.

Finally, the initial string is defined. It is the first string to be processed in the algorithm. From this initial state, the system evolves over time. In this example, it is defined as:

\[w_{0}=B^{cfe}\]	
	
	
	


%___________________________________________________________________________
\section{Conclusions and Future Work
\label{sec:conclusions}}
%___________________________________________________________________________

En el presente artículo se ha propuesto unificar las características más sobresalientes de los SMA y SG. Para ello se ha definido un lenguaje especificado mediante gramáticas independientes del contexto que determinan los elementos que componen el sistema. Se han establecido determinadas funciones que representan la evolución de cada uno de los agentes a través del tiempo y se han definido funciones que extraen la representación gráfica de los agentes. Esta representación se envía a los dispositivos geométricos, visuales o no, mediante funciones que separan la implementación concreta sobre un dispositivo geométrico y la descripción geométrica del agente.

La separación de los dispositivos de entrada, tanto hardware como software, de la definición del sistema se ha articulado a través de los generadores de eventos, que levantan una capa entre el dispositivo y la representación del sistema. De esta manera además se añade interactividad con la cadena en evolución.
Se ha diseñado un sistema de comunicación entre los procesos geométricos que definen un motor físico y los agentes que componen una escena. El componente que articula esta comunicación es el generador de eventos. Este generador puede aprovechar el hardware dedicado para motor físico o implementar la funcionalidad necesaria mediante software. Una vez que se ha tratado y clasificado la información, se envía a los diferentes agentes mediante eventos para que reaccionen a la información generada por el motor físico. Por ejemplo, si se quiere que un agente reaccione ante una colisión, el generador de eventos de este tipo calculará las colisiones de los elementos extrayendo la geometría de la escena gracias al motor gráfico (utilizando la implementación de las funciones α, β, δ para calcular los cubos envolventes de los elementos) y generando los eventos necesarios para las colisiones.

	Las funciones de evolución de los agentes son los elementos necesarios para implementar todas las características requeridas por un SMA. En estas funciones es donde cada agente va a tomar sus decisiones dependiendo de su estado actual, va a comunicarse con otros agentes generando eventos y va a poder observar su entorno gracias al motor físico implementado mediante generadores de eventos. Mediante eventos se pueden ejecutar actividades que cambien el estado del agente y que modifiquen su comportamiento. Además, como el propio agente puede generar eventos, es posible diseñar los procesos de comunicación utilizados en SMA. También queda garantizada la integración entre motor físico y SMA, ya que estos dos motores se relacionan entre sí mediante los eventos.
El uso de un lenguaje para la descripción de los elementos de la escena y la independencia del sistema gráfico hace que estas cadenas descriptivas puedan ser reutilizadas en cualquier otro sistema, siempre y cuando estén implementados los elementos básicos (todas las funciones semánticas explicadas en la sección 4).

	Este modelo abre diferentes expectativas que podrán ser exploradas en el futuro. Por ejemplo, el desarrollo de agentes que estén compuestos por otros agentes. El lenguaje L(M) deja abierta la posibilidad de definir agentes como rbj(si·tr), con r,s,t ∈ AD. Esto significa que el agente r está compuesto por dos agentes más. Los eventos que recibe r podrían pasar a 's' y 't' o no, o incluso r podría pasar otros eventos diferentes dependiendo de los que recibiera él. Esto define una dependencia entre agentes. Pero esta dependencia puede crearse en tiempo de ejecución del sistema. Por ejemplo, si se supone que se tiene la cadena rb·sq, con r y s como agentes, se podría desarrollar una dependencia entre r y s, de tal manera que, si se produce un determinado evento, la cadena anterior quede como rb(sq). Esto podría significar que dos agentes que antes existían independientemente ahora podrían formar un sólo agente. Este tipo de operaciones son muy interesantes ya que recuerdan a procesos de agregación celular. Así se podrían desarrollar algoritmos que de forma espontánea, y dependiendo de determinadas condiciones, se pase de organismos unicelulares (cuando los agentes son independientes entre sí) a organismos multicelulares.
	
	Prosiguiendo con las similitudes biológicas también se podrían estudiar el desarrollo de algoritmos genéticos. En este caso, dado un agente como rabc, se podría definir una función de evolución que dado un evento (que representaría la reproducción), pueda producir la reproducción de r pero con modificaciones en la cadena de eventos a los que pueda reaccionar. Es decir, se podría reproducir como la cadena  rab o incluso incluir otros eventos como rabd.
	
	También se podría considerar la posibilidad de ejecutar acciones asociadas a eventos pero con una cierta probabilidad. Es decir, si se define un agente como rab y este agente recibiera el evento ea la función asociada a la ejecución de este evento se ejecutaría pero sólo con una cierta probabilidad. Esto podría servir para algoritmos que utilicen la probabilidad como elemento fundamental en su función de evolución. Por ejemplo, se podrían usar definiciones de aprendizaje de un agente mediante sistemas probabilísticos.
	
	Una posible área de aplicación del modelo podría ser la robótica, en la cual existe un uso exhaustivo de los SMA.  Un robot puede comportarse como un agente o un conjunto de agentes y, tanto su representación como sus acciones, se podrían especificar como un conjunto de primitivas que hacen que el robot se mueva hacia diferentes lugares. Por ejemplo, una acción de nuestro sistema puede ser “mueve brazo”. Esta primitiva puede mover un brazo virtual si hablamos de una simulación gráfica, o mover un brazo robótico real. Los diferentes sensores pueden definir un generador de eventos que tratarían la señal del sensor y pasarían a los agentes la información que necesitan.
En definitiva, se ha pretendido dar una solución que integra lo mejor de los SMA y SG y cuya aplicación puede aplicarse en toda la gran diversidad de problemas que intenta abordar los SMA, con el enriquecimiento que supone usar los SG para el análisis de los datos que genera los agentes en la evolución de un sistema con agentes de diversa naturaleza.












\begin{thebibliography}{0}

\bibitem[PhyX]{Physx}
PhysX by AGEIA:
http://physx.ageia.com

\bibitem[DJK05]{David2005}
David J.~Kasik William~Buxton D. R.~F.:
Ten cad challenges.
IEEE Computer Graphics and Applications 25 (2005), 81--90

\bibitem[WMod]{WModel}
Working Model: Simulaci\'on de Sistemas:
http://www.design-simulation.com

\bibitem[DW94]{Davis1994}
Davis Martin D.;~Sigal R., Weyuker E.~J.:
Computability, Complexity, and Languages, Fundamentals of Theoretical Computer
Science, 2nd~ed.
San Diego: Elsevier Science, 1994

\bibitem[NGDy]{NGDynamics}
Newton Game Dynamics:
http://www.newtondynamics.com

\bibitem[ODEn]{ODE}
Open Dynamics Engine:
http://www.ode.org

\bibitem[WPEn]{Wikipedia2007}
Wikipedia - Physics engine:
http://en.wikipedia.org/wiki/physics\_engine

\bibitem[Havok]{Havok}
Havok:
http://www.havok.com

\bibitem[JHM07]{John2007}
John H.~Miller S. E.~P.:
Complex Adaptative Systems.
Princeton University Press, 2007

\bibitem[Joshua2004]{Joshua2004}
Joshua~Strickon J. A.~P.:
Emerging technologies.
Siggraph (2004)

\bibitem[PALay]{PAL}
PAL: Physics Abstraction Layer:
http://www.adrianboeing.com/pal/

\bibitem[DirX]{DirectX}
Página oficial de DirectX:
http://www.microsoft.com/windows/directx/default.mspx

\bibitem[OpGL]{OpenGL}
Página oficial de OpenGL:
http://www.opengl.org/

\bibitem[SDLay]{SDL}
Simple DirectMedia Layer (SDL):
http://www.libsdl.org

\bibitem[OGRE]{OGRE}
OGRE 3D: Open source graphics engine:
http://www.ogre3d.org

\bibitem[VTK]{VTK}
The Visualization ToolKit (VTK):
http://public.kitware.com/vtk

\bibitem[EOECF]{EOECF}
EO Evolutionary Computation Framework:
http://eodev.sourceforge.net

\bibitem[CILib]{CILib}
CILib (Computational Intelligence Library):
http://cilib.sourceforge.net

\bibitem[wiiNintendo]{wiiNintendo}
Wii-Nintendo:
http://www.nintendo.es

\bibitem[Jade]{Jade}
Jade - Java Agent DEvelopment Framework:
http://jade.tilab.com

\bibitem[Lai01]{Laird2001}
Laird J.~E.:
Using a computer game to develop advanced ai.
Computer 34 (7) (2001), 70--75

\bibitem[GNY04]{Georgios2004}
Georgios N.~Yannakakis John~Levine J.~H.:
An evolutionary approach for interactive computer games.
In Proceedings of the Congress on Evolutionary Computation (2004), 986--993.

\bibitem[CM07]{Chris2007}
Chris~Miles Juan~Quiroz R. L. S. J.~L.:
Co-evolving influence map tree based strategy game players.
IEEE Symposium on Computational Intelligence and Games (2007), 88--95

\bibitem[RGR05]{Robert2005}
Robert G.~Reynolds Ziad~Kobti T. A. K. L. Y. L.~Y.:
Unraveling ancient mysteries: Reimagining the past using evolutionary
  computation in a complex gaming environment.
IEEE transactions on evolutionary computation 9 (2005), 707--720

\bibitem[Woo97]{Wooldridge1997}
Wooldridge M.:
Agent-based software engineering.
IEEE Proceedings Software Engineering 144 (1997), 26--37.

\bibitem[WD00]{Wood2000}
Wood M.~F., DeLoach S.:
An overview of the multiagent systems engineering methodology.
AOSE (2000), 207--222

\bibitem[Ken06]{Kenyon2006}
Kenyon S.~H.:
Behavioral software agents for real-time games.
IEEE Potentials 25 (2006), 19--25

\bibitem[AK02]{Aaron2002}
Aaron~Khoo R.~Z.:
Applying inexpensive ai techniques to computer games.
IEEE Intelligent Systems 17(4) (2002), 48--53

\end{thebibliography}



\end{document}
